
var INLINESTORE = {};INLINESTORE["minicore"] = "\nvar modtask = \n{\n	platform : false,\n	usermodule : false,\n\n	// Kernel\n	// Kernel.rootmodule [Minicore]\n	// Kernel.rootmodule.usermodule [Usermodule at build time]\n	// usermodule at a minimum must implement servicecallback  \n	servicecallback : function(evt, platobject)\n	{\n 		if (evt == \"systemstart\")\n		{\n			// load the platform module first \n			// Do not use loadModuleInModtask. we dont want to override the Log, Sleep, etc. :)\n			\n			if (typeof(platobject) == \"object\" && typeof(platobject[\"overridehostingmodule\"]) == \"string\")\n			{\n				modtask.platform = Kernel.loadModule(modtask, platobject[\"overridehostingmodule\"]); \n				modtask.platform[\"platobject\"] = platobject[\"platobject\"];\n			}\n			else \n			{\n				modtask.platform = Kernel.loadModule(modtask, \"host/nodejs/base\"); \n				modtask.platform[\"platobject\"] = platobject;\n			}				\n\n			// redirect these to the platform counterparts \n			Kernel.Log = modtask.platform.Log;\n			Kernel.Sleep = modtask.platform.Sleep;\n			Kernel.exceptionToString = modtask.platform.exceptionToString;\n			Kernel.getPlatformModule = function() { return modtask.platform; };\n			Kernel.getBuildInfo = function() { return \"2020-03-30 15:08:05\"; } ;\n			Kernel[\"getModulePath\"] =  function(name)\n			{\n				if (typeof(modtask.platform.modspath[name]) != \"string\")\n					Kernel.Fail(\"getModulePath \" + name);\n				return modtask.platform.modspath[name];\n			};\n\n			Kernel[\"getRootPathIfAny\"] = function() {\n				var ret = \"\";\n				try { \n					if (typeof(Kernel.rootModule.usermodule[\"getRootPathIfAny\"]) == \"function\")\n						ret = Kernel.rootModule.usermodule[\"getRootPathIfAny\"]();\n				} catch(e) { }\n				return ret;\n			}\n			// Fix these \n			modtask.Log = Kernel.Log;\n			modtask.Sleep = Kernel.Sleep;\n			modtask.exceptionToString = Kernel.exceptionToString;\n			modtask.getPlatformModule = Kernel.getPlatformModule;\n			Kernel[\"systemhealthymsg\"] = \"System Healthy. 100 percent pass rate for modules\";\n \n			try \n			{\n				modtask.usermodule = Kernel.loadModuleInModtask(modtask, \"izymodtask/entrypoint\");\n				modtask.usermodule.servicecallback(\"init\"); \n			}\n			catch(e)\n			{\n 				var txt = \"CRASH in usermodule: \" + Kernel.exceptionToString(e);\n 				modtask.platform.showUnhandledKernelExceptionMsg(txt);\n				return txt;\n			} \n		}\n		return evt;\n	},\n\n	externalCall : function(obj, failed)\n	{\n		var msg = \"\";\n		try \n		{\n			if (failed)\n			{\n				msg = obj[\"p\"];\n			}\n			else\n			{\n				return obj[\"fn\"](obj[\"p\"]);\n			}\n 		}\n		catch(e)\n		{\n			failed = true;\n			msg = Kernel.exceptionToString(e);\n		}  \n		var ctx = \"\";\n		if (obj[\"context\"])\n			ctx = obj[\"context\"];\n		var txt = \"externalCall \" + ctx + \" :::\" + msg + \"\";\n		modtask.platform.showUnhandledKernelExceptionMsg(txt);\n		return txt;		\n	},		\n\n	getDependencies : function(moduleconfig)\n	{\n		var ret =  []; \n		return ret;		\n	}\n}\n"; 
INLINESTORE["host/nodejs/base"] = "\r\nvar modtask =\r\n{\r\n	platobject : false,\r\n\r\n	modspath : \r\n	{\r\n		\"file\" : \"host\\\\nodejs\\\\file\",\r\n		\"proc\" : \"host\\\\nodejs\\\\proc\",\r\n		\"http\" : \"host\\\\nodejs\\\\http\",\r\n		\"pinger\" : \"host/nodejs/pinger\",\r\n		\"osdependentfilecommon\" : \"host/nodejs/filecommon\"\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = [];\r\n		return ret;\r\n	},\r\n\r\n	getModulePath : function(name)\r\n	{\r\n		if (typeof(modtask.modspath[name]) != \"string\")\r\n			Kernel.Fail(\"getModulePath \" + name);\r\n		return modtask.modspath[name];\r\n	},\r\n\r\n	endRuntime : function()\r\n	{\r\n		Kernel.Fail(\"endRuntime for nodejs\");\r\n	},		\r\n\r\n 	showUnhandledKernelExceptionMsg : function(str)\r\n	{\r\n		try { console.log(str);} catch(e) { console.log(\"host.nodejs.showUnhandledKernelExceptionMsg.Failed\"); }\r\n	},		\r\n	\r\n	\"Log\" : function(s) \r\n	{\r\n 		try { console.log(s); } catch(e) { console.log(\"host.nodejs.Log.Failed\"); }\r\n	},\r\n\r\n	\"Sleep\" : function(miliseconds) \r\n	{\r\n	      try \r\n	      {  \r\n		 var sleep = require('sleep');\r\n		 sleep.usleep(miliseconds*1000);\r\n	      }\r\n	      catch(e)\r\n	      {\r\n		 console.log(\"host.nodejs: \" + modtask.exceptionToString(e));\r\n	      }      \r\n	},\r\n\r\n	\"exceptionToString\" : function(e) \r\n	{ \r\n		var ret  = \"\";\r\n		if (typeof(e[\"message\"]) == \"string\")\r\n		{ 	 \r\n			ret = e.message;	\r\n		}\r\n		else  \r\n		{\r\n			ret = JSON.stringify(e);\r\n		}\r\n		return ret;   	\r\n	}\r\n}\r\n\r\n"; 
INLINESTORE["izymodtask/entrypoint"] = "// both usermodule (izymodtask/entrypoint) and modtask/minicore.platform via host/nodejs/base\n// see modtask/minicore.servicecallback for more details\n// for usermodule reference see modtask/codegen/console/root.js\n\nvar modtask = function() {}\n\n// Set from the index.js file\nmodtask.__contextualName = null;\nmodtask.__rootPathForAnchorDirectory = null;\nmodtask.verbose = {\n  startup: false,\n  setupSelectors: false,\n  loadObject: false,\n  objectExist: false,\n  iterateStoreChain: false,\n  getObjectPath: false,\n  iteratePathsToSearch: false\n};\n\nif (modtask.verbose.startup) console.log('entrypoint');\n\n/************** Kernel Interfaces ****************/\nmodtask.platform = null; // set by modtask/minicore.servicecallback\nmodtask.Log = function(x) {\n  console.log(x);\n}\nmodtask.Sleep = function() {\n  console.log('Warning, sleep not supported in nodejs');\n}\nmodtask.exceptionToString = function(e) {\n  return e.message;\n}\nmodtask.showUnhandledKernelExceptionMsg = function(txt) {\n  console.log('showUnhandledKernelExceptionMsg: ', txt);\n}\nmodtask.modspath = {};\n/* ^^^^^^^^^^^^^ Kernel Interfaces ^^^^^^^^^^^^^*/\n\n\n/************** usermodule Interfaces ****************/\nmodtask.servicecallback = function(evt) {\n  if (modtask.verbose.startup) console.log('servicecallback');\n  Kernel.verbose = modtask.verbose;\n  if (Minicore.loadObjectOverwrite) {\n    console.log('Selectors Already Setup');\n  } else {\n    // do it twice to force reload from the file system (if present)\n    modtask.setupSelectors();\n    modtask.setupSelectors();\n  }\n};\n\n// getRootPathIfAny will tell the system where ljs.js is located at\n// ITS a bad naming -- it is a Full File Path and that is why if non-empty, it should always end with /\n// modtask/minicore will set Kernel.getRootPathIfAny to this\n// kernel/extstores/file will use Kernel.getRootPathIfAny to calculate getAnchorDirectory (appends ./modtask to it)\n\nmodtask.getRootPathIfAny = function() {\n  return modtask.__rootPathForAnchorDirectory;\n}\n\n/* ^^^^^^^^^^^^^ usermodule Interfaces ^^^^^^^^^^^^^*/\n\nmodtask.setupSelectors = function() {\n  if (modtask.verbose.setupSelectors) console.log('setupSelectors');\n  var modsel = modtask.ldmod('kernel\\\\selectors');\n  modsel.verbose = modtask.verbose;\n  modsel.redirectStorage();\n  modsel.addStoreChain('kernel\\\\extstores\\\\file', true, modtask.verbose);\n}\n\nmodtask.__$d = ['kernel\\\\selectors', 'kernel\\\\extstores\\\\file', 'host\\\\nodejs\\\\file', 'host\\\\nodejs\\\\filecommon'];\n"; 
INLINESTORE["kernel\\selectors"] = "\r\nvar modtask = {\r\n	// gets set by loaders\r\n	verbose: {\r\n\r\n	},\r\n\r\n	file : false,\r\n	modstr : false,\r\n	storemods : {},\r\n	modsql : false,\r\n\r\n	iterateModules : function(context) {\r\n		modtask.iterateStoreChain(\r\n		{\r\n			\"fn\" : function(a,b, mod)\r\n			{\r\n				mod.iterateModules(context); \r\n			}\r\n		}\r\n		);\r\n	},\r\n\r\n	objectExist : function(objectname, details, loadtoo) {\r\n		if (modtask.verbose.objectExist) console.log('objectExist [loadtoo = ' + loadtoo + ']', objectname);\r\n 		if (typeof(details) != \"object\") details = {};\r\n		details[\"chainstr\"] = [];\r\n		var exists = false;\r\n		modtask.iterateStoreChain({\r\n			\"fn\" : function(a, chainName, mod) {\r\n				if (modtask.verbose.iterateStoreChain) console.log('delegate objectExist to: ' + chainName);\r\n				details[\"chainstr\"][details[\"chainstr\"].length] = chainName;\r\n				if (mod.objectExist(objectname, details, loadtoo)) {\r\n					exists = true;\r\n					return \"break\";\r\n				} \r\n			}\r\n		});\r\n  		details[\"found\"] = exists;\r\n        modtask.objectExistsHook(objectname, details);\r\n		return exists;\r\n	},\r\n\r\n   objectExistsHook : function() { },\r\n\r\n	redirectStorage : function() {\r\n		if (Minicore.loadObjectOverwrite == false)\r\n			Minicore.loadObjectOverwrite = modtask.loadObject2;\r\n		else\r\n		{	\r\n			// It should only be set to me :)\r\n			if (Minicore.loadObjectOverwrite != modtask.loadObject2)\r\n				modtask.Fail(\"redirectStorage called after already been set\");		\r\n		}\r\n	},\r\n\r\n	loadObject2 : function(_modtask, objecttype, objectname, inithash, donotcallinit, funcs) {\r\n		if (modtask.verbose.loadObject) console.log('kernel/selectors.loadObject2', objectname);\r\n		var ret ;\r\n		// I am a singleton -- :-)\r\n		if (objectname == modtask.__myname)\r\n			return modtask; \r\n\r\n		if (typeof(funcs) != \"object\" || typeof(funcs[\"existfunc\"]) != \"function\" || typeof(funcs[\"parsefunc\"]) != \"function\") {\r\n			var details = {};\r\n			if (modtask.objectExist(objectname, details, true)) {\r\n				ret = Minicore.rawLoadObject(_modtask, objecttype, objectname,\r\n					function() {\r\n						return details[\"obj\"];\r\n					});\r\n			} else\r\n				_modtask.Fail(Minicore.EncodeDecode_encodeErrorMessage(\"loadObject2\", Minicore.ERR_DOESNOT_EXIST, objectname));\r\n		}\r\n		else \r\n		{\r\n			ret =  Minicore.loadObject2(_modtask, objecttype, objectname, inithash, donotcallinit, funcs);\r\n\r\n		}\r\n		return ret;\r\n	},\r\n\r\n	getUnparsedObj : function(objref) {\r\n		var details = { \"unparsed\" : true };\r\n		if (modtask.objectExist(objref, details, true))\r\n			return details[\"obj\"];\r\n		else \r\n			modtask.Fail(\"getUnparsedObj. not exists \" + objref);\r\n 	},\r\n\r\n	augmentConfig : function(_modtask, failifnot, failforinfo) {\r\n		var details = {};\r\n		details[\"failifnot\"] = failifnot;\r\n		details[\"failforinfo\"] = failforinfo;\r\n		return modtask.configExists(_modtask, details, true);\r\n	},\r\n\r\n	configExists : function(_modtask, details, loadtoo) {\r\n		if (typeof(_modtask[\"configname\"]) != \"string\")\r\n		{\r\n			modtask.Fail(\"you must define 'configname' for \" + _modtask.__myname + \", since it tries to augmentConfig\");\r\n		}\r\n  		details[\"found\"] = false;\r\n		details[\"pathstrs\"] = \"\";\r\n		details[\"__modparent\"] = _modtask.__myname;\r\n		var paths = [\"..\\\\thirdparty\\\\config\\\\\" + _modtask.configname, \"config\\\\\" + _modtask.configname];\r\n		for(i=0; i < paths.length; ++i)\r\n		{\r\n			details[\"pathstrs\"] += \", \" + paths[i];\r\n	 		if (modtask.objectExist(paths[i], details, loadtoo))\r\n			{\r\n				details[\"found\"] = paths[i];\r\n				if (loadtoo)\r\n				{\r\n					details[\"obj\"][\"__modparent\"] = _modtask;	\r\n					modtask.augmentModule(_modtask, details[\"obj\"]);\r\n				}\r\n				break;\r\n			}\r\n		}\r\n 		if ((details[\"failifnot\"] && details[\"found\"] == false) || details[\"failforinfo\"])\r\n		{\r\n 			modtask.Fail(\"augmentConfig.formatLoadInfo: \" + modtask.formatLoadInfo(details));\r\n		}\r\n		return modtask;\r\n	},\r\n\r\n	getPathToCurrentConfigModule : function(_modtask) {\r\n		var details = {};\r\n		modtask.configExists(_modtask, details, false);\r\n		if (details[\"found\"])\r\n			return details[\"found\"];\r\n		else \r\n			modtask.Fail(\"getPathToCurrentConfigModule \" + _modtask.__myname);\r\n 	},\r\n\r\n	formatLoadInfo : function(details, breakdownformat) {\r\n		var info = Minicore.newLine, p, i, chainstore;\r\n		var chaininfo = \"\", foundinfo = \"\";\r\n\r\n		foundinfo = (details[\"found\"] ? \"module found\" : \"module is missing\" ) + Minicore.newLine;\r\n		info += \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" + Minicore.newLine;\r\n		info += foundinfo;\r\n		info += \"__modparent: \" + details[\"__modparent\"] + Minicore.newLine;\r\n		info +=	\"Tried to load these modules: \" + details[\"pathstrs\"] + Minicore.newLine;\r\n		info += \"Chains where: \";\r\n		for(i=0; i < details[\"chainstr\"].length; ++i)\r\n		{\r\n			chainstore = details[\"chainstr\"][i];\r\n			chaininfo += Minicore.newLine + chainstore;\r\n			if (details[chainstore])\r\n			{\r\n				chaininfo += \" [ \";\r\n				for(p in details[chainstore])\r\n					chaininfo += details[chainstore][p] + \" \";\r\n				chaininfo += \" ] \";\r\n			}\r\n		}		\r\n		chaininfo += Minicore.newLine;\r\n		info += chaininfo;\r\n		if (details[\"found\"])\r\n		{\r\n			// placeholder \r\n			info += \"storagetype: \" + details[\"storagetype\"] + Minicore.newLine; \r\n			info += \"__loadObject2Path: \" + details[\"obj\"][\"__loadObject2Path\"] + Minicore.newLine ;\r\n			info += \"OBJECTDUMP\";\r\n			for(p in details[\"obj\"])\r\n				info += Minicore.newLine + \"  \" + p + \": \" + details[\"obj\"][p];\r\n		}\r\n 		info += \"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" + Minicore.newLine;\r\n\r\n		if (breakdownformat)\r\n		{\r\n			return { \"chaininfo\" : chaininfo, \"foundinfo\" : foundinfo} ;\r\n		}\r\n		else \r\n		{\r\n			return info;\r\n		}\r\n	},\r\n\r\n	getValidator : function() {\r\n		var ret =false;\r\n		if (modtask.objectExist(\"codegen\\\\validator\"))\r\n			ret = modtask.ldmod(\"codegen\\\\validator\");\r\n		return ret;\r\n	},\r\n\r\n	augmentModule : function(obj1, obj2) {\r\n		var p;\r\n		if (!obj2)\r\n			return obj1;\r\n		for(p in obj2)\r\n		{\r\n			if (p.indexOf(\"__\") == 0)\r\n				continue;\r\n			obj1[p] = obj2[p];\r\n		}\r\n		return obj1;\r\n	},\r\n\r\n	validateConfig : function(_modtask, prop, type)\r\n	{	\r\n		if (typeof(_modtask[prop]) != type)\r\n 			modtask.Fail(\"validateConfig failed for \" + prop + \" on \" + _modtask.__myname); \r\n		return modtask;\r\n	},\r\n\r\n\r\n	init : function() {\r\n		modtask.modstr = Kernel.loadModuleInModtask(modtask, \"core\\\\string\"); \r\n		modtask.addStoreChain(\"kernel\\\\extstores\\\\inline\");\r\n 	},			\r\n\r\n	iterateStoreChain : function(ctx) {\r\n		var p, i=0;\r\n		var order = [\"kernel/extstores/webstorage\", \"kernel\\\\extstores\\\\file\", \"kernel\\\\extstores\\\\inline\"];\r\n		var j;\r\n		for(j=0; j < order.length; ++j) {\r\n			p = order[j]; \r\n			if (modtask.storemods[p]) {\r\n				if (modtask.verbose.iterateStoreChain) console.log('iterateStoreChain', p);\r\n				if (ctx[\"fn\"](i++, p, modtask.storemods[p]) == \"break\")\r\n					break;\r\n			}\r\n		}\r\n	},\r\n\r\n	reconfigStoreChain : function(chainname, failifnot, failforinfo)\r\n	{\r\n		modtask.augmentConfig(modtask.storemods[chainname], failifnot, failforinfo); 	\r\n	},\r\n\r\n	addStoreChain : function(chainname, allowredo, verbose) {\r\n		// Avoid loops \r\n		if (typeof(modtask.storemods[chainname]) == \"object\" && !allowredo)\r\n			return modtask.storemods[chainname];\r\n		modtask.storemods[chainname] = modtask.ldmod(chainname);\r\n		modtask.storemods[chainname].verbose = verbose || {};\r\n		modtask.reconfigStoreChain(chainname); 		\r\n		if (typeof(modtask.storemods[chainname][\"afterAdd\"]) == \"function\")\r\n			modtask.storemods[chainname][\"afterAdd\"](modtask);\r\n		modtask.storemods[chainname][\"ldmod\"] = function(x) { modtask.Fail(\"StoreChain may only loadObject/ldmod on init. Fix this for \" + chainname); } ;\r\n		return modtask.storemods[chainname];\r\n	},		\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\extstores\\\\inline\"]  \r\n		];\r\n		return ret;\r\n	}	\r\n}\r\n"; 
INLINESTORE["core\\string"] = "\r\nvar modtask = \r\n{\r\n	VERIFY_STRING2 : function(res, val)\r\n	{\r\n		return modtask.VERIFY_STRING(modtask, res, val);\r\n	},\r\n\r\n	VERIFY_STRING : function(ctx, res, val)\r\n	{		\r\n		if (res != val || typeof(res) == \"undefined\" || typeof(val) == \"undefined\")\r\n			ctx.Fail(Minicore.newLine + \"VERIFY_STRING(\" + Minicore.newLine + \"'\" + (res + \"\").replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\") + \"'\" + Minicore.newLine + \" !=  \" + Minicore.newLine +  \"'\" + val + \"')\");\r\n	},\r\n\r\n	VERIFY_SUBSTRING2 : function(res, val)\r\n	{\r\n		if (typeof(res) == \"undefined\" || typeof(val) == \"undefined\" || !modtask.contains(res, val))\r\n			modtask.Fail(\"VERIFY_SUBSTRING(\" + Minicore.newLine + \"'\" + res + \"'\" + Minicore.newLine + \" NOT_SUPERSTRING \" + Minicore.newLine +  \"'\" + val + \"')\");\r\n	},		\r\n\r\n	splitLast : function(str, token)\r\n	{\r\n		var tmp = str.split(token);\r\n		if (tmp.length <2) modtask.Fail(\"splitLast.\" + str + \".\" + token);\r\n		var ret = [];\r\n		ret[0] = \"\";\r\n		ret[1] = tmp[tmp.length-1];\r\n		ret[0] = str.substr(0, str.length-ret[1].length-token.length);\r\n		return ret;\r\n	},		\r\n	\r\n	replaceTokens : function(content, tokens)\r\n	{\r\n		var p;\r\n		for(p in tokens)\r\n		{\r\n			var exp = p.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\[/g,\"\\\\[\").replace(/\\$/g, \"\\\\$\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\");\r\n 			var re = new RegExp(exp,\"g\");\r\n			content = content.replace(re, tokens[p]);		\r\n		}\r\n		return content;\r\n	},\r\n\r\n	toByteArray : function(str)\r\n	{\r\n		var i, ret = [];\r\n		for(i=0; i < str.length; ++i)\r\n			ret[i] = str.charCodeAt(i);\r\n	       return ret;	\r\n	},\r\n		\r\n	trim : function(str, extra)\r\n	{\r\n		str = str.replace(/^\\s+|\\s+$/g, \"\");		\r\n		if (extra == \"nonprintable\")			\r\n			str = str.replace( /[^a-zA-Z0-9\\s-@\\.\\<\\>=\"'_\\\\\\&,\\/]/g, \"\"); \r\n		return str;\r\n	},\r\n\r\n	contains : function(str1, str2)\r\n	{\r\n		var i;\r\n		if (typeof(str2) == \"object\")\r\n		{\r\n			for(i=0; i < str2.length; ++i)\r\n				if (modtask.contains(str1, str2[i]))\r\n					return true; \r\n		}\r\n		str1 = str1 + \"\";str2 = str2 + \"\";\r\n		return (str1.indexOf(str2) >= 0);\r\n	},\r\n\r\n	noCapsPresent : function(str)\r\n	{\r\n		return str.match(/[A-Z]+/) == null;\r\n\r\n	},\r\n\r\n\r\n	strClean1013 : function(str, rpl, keep1013)\r\n	{\r\n		var ret = \"\";\r\n		var i;\r\n		for(i=0; i < str.length; ++i)\r\n		{\r\n			if (str.charCodeAt(i) == 13 || str.charCodeAt(i) == 10)\r\n			{\r\n				if (keep1013)\r\n					ret += str.substr(i,1);			\r\n				if (rpl)\r\n					ret += rpl\r\n				continue;\r\n			}\r\n			else \r\n				ret += str.substr(i,1);\r\n\r\n		}\r\n		return ret;\r\n	},	\r\n\r\n	startsWith : function(str1, str2)\r\n	{\r\n		var core = modtask.ldmod(\"core\\\\core\");\r\n		if (core.realTypeOf(str2) == \"array\")\r\n		{\r\n			var p;\r\n			for(p in str2)\r\n			{\r\n				if (this.startsWith(str1, str2[p]))\r\n					return true;\r\n			}\r\n			return false;\r\n		}\r\n		// placeholder \r\n		if (str1.length >= str2.length)\r\n		{\r\n			if (str1.substr(0, str2.length) == str2)\r\n				return true;\r\n		}\r\n		return false;\r\n	},		\r\n\r\n	endsWith : function(str1, str2)\r\n	{\r\n		if (str1.length >= str2.length)\r\n		{\r\n			if (str1.substr(str1.length-str2.length, str2.length) == str2)\r\n				return true;\r\n		}\r\n		return false;\r\n	},\r\n\r\n	nSpace: function(s,n)\r\n	{\r\n		return modtask.nStrrpt(s, n, \" \");\r\n	},\r\n\r\n	nStrrpt : function(s,n, str)\r\n	{\r\n		var ret = s + \"\";\r\n		while(ret.length < n)\r\n			ret += str;\r\n		return ret;\r\n	},\r\n\r\n	twoDigits : function(s)\r\n	{\r\n		if (s < 10)\r\n			return \"0\" + s;\r\n		else \r\n			return s;\r\n	},\r\n\r\n	randomNDigit : function(n)\r\n	{\r\n		var i;\r\n		var ret = \"\";\r\n		for (i=0; i < n ; ++i)\r\n			ret += (Math.round(Math.random()*1000) + \"\").substr(0,1);\r\n		return ret;\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n		var ret =  \r\n		[\r\n			[\"modtask\", \"core\\\\core\"] \r\n		]; \r\n		return ret;		\r\n	} \r\n}\r\n\r\n"; 
INLINESTORE["core\\core"] = "\r\nvar modtask = \r\n{\r\n	isUndef : function(v)\r\n	{\r\n		return (typeof(v) == \"undefined\");\r\n	},\r\n\r\n	realTypeOf : function(v) {\r\n	  if (typeof(v) == \"object\") {\r\n	    if (v === null) return \"null\";\r\n		// The constructor based approach (v.constructor == (new Array).constructor ) does not work\r\n		  // when objects are compared cross window (i.e. ide editor)\r\n		  if (Object.prototype.toString.call(v) == Object.prototype.toString.call([])) return \"array\";\r\n	    if (v.constructor == (new Date).constructor) return \"date\";\r\n	    if (v.constructor == (new RegExp).constructor) return \"regex\";\r\n	    return \"object\";\r\n	  }\r\n	  return typeof(v);\r\n	},        \r\n\r\n	arrayMatch : function(p, arr)\r\n	{\r\n		var i;\r\n		for(i=0; i < arr.length; ++i)\r\n			if (p.match(arr[i]))\r\n				return true;\r\n		return false;\r\n	},\r\n		\r\n	arrayIndexExactMatch : function(p, arr)\r\n	{\r\n		var i;\r\n		for(i=0; i < arr.length; ++i)\r\n		{\r\n			if (p == arr[i])\r\n				return i;\r\n		}\r\n		return -1;\r\n	},\r\n\r\n	verifyArgs : function()\r\n	{\r\n		modtask.Fail('deprecated/use/core/verify.verifyArgs');\r\n	},\r\n\r\n	augmentObject :function(obj1, obj2)\r\n	{\r\n		var p;\r\n		if (!obj2)\r\n			return obj1;\r\n		for(p in obj2)\r\n			obj1[p] = obj2[p];\r\n		return obj1;\r\n	},\r\n\r\n	augmentArray : function(arr1, arr2)\r\n	{\r\n		var i;\r\n		var j = arr1.length;\r\n		for(i=0; i < arr2.length;++i)\r\n			arr1[j++] = arr2[i];\r\n		return arr1;\r\n	},\r\n\r\n   cloneFunction : function(fn, max, now)\r\n   {\r\n    var that = fn;\r\n    var temp = function temporary() { return that.apply(fn, arguments); };\r\n    for( key in fn ) {\r\n        temp[key] = modtask.cloneObject(fn[key], max, now + 1);\r\n    }\r\n    return temp;\r\n   },                  \r\n\r\n	cloneObject : function(obj, max, now) \r\n   {\r\n      if (!max) max = 10;\r\n      if (!now) now = 1;\r\n      if (now > max)\r\n         modtask.Fail(\"cloneObject.cannot.go.deeper than.\" + max);\r\n\r\n      if (typeof(obj) == \"function\")\r\n         return modtask.cloneFunction(obj, max, now);       \r\n      if(obj == null || typeof(obj) != 'object')\r\n         return obj; \r\n      if (modtask.realTypeOf(obj) == \"array\")\r\n         return obj.slice(0);  \r\n      var temp = {};       \r\n      for(var key in obj)\r\n         temp[key] = modtask.cloneObject(obj[key], max, now+1);\r\n      return temp;\r\n	},\r\n\r\n   // order is important \r\n	patchObject : function(obj, patch)\r\n        {\r\n		var newobj = modtask.cloneObject(obj);\r\n		var p;\r\n		for(p in obj) if (!modtask.isUndef(patch[p])) newobj[p] = patch[p]; \r\n		return newobj;\r\n	}, 		      \r\n\r\n	arrayIndexMatch :function(p, arr, reverse)\r\n	{\r\n		var i;\r\n		p = p + \"\";\r\n		for(i=0; i < arr.length; ++i)\r\n		{\r\n			if (p.length > 0 && arr[i].length < 1)\r\n				continue;\r\n			if (reverse)\r\n			{\r\n				if (arr[i].match(p))\r\n					return i;\r\n			}\r\n			else \r\n			{\r\n				if (p.match(arr[i]))\r\n					return i;\r\n			}\r\n		}\r\n		return -1;\r\n	},\r\n\r\n	objToArr : function(obj)\r\n	{\r\n		var p, ret = [];\r\n		for(p in obj) ret[ret.length] = p;\r\n		return ret;\r\n	},		\r\n\r\n	getFirstElement : function(obj)\r\n	{\r\n		var p;\r\n		for(p in obj) { break; } ;		\r\n		return p;\r\n	},\r\n\r\n	isEmpty : function(obj)\r\n	{\r\n		var p;\r\n		for(p in obj) return false;\r\n		return true; \r\n	},\r\n\r\n	obj : function(p, v) { var ret = {}; ret[p] = v; return ret; } \r\n}\r\n"; 
INLINESTORE["kernel\\extstores\\inline"] = "\r\nvar modtask =\r\n{\r\n	configname : \"kernel\\\\extstores\\\\inline\",\r\n\r\n 	objectExist : function(objectname, details, loadtoo)\r\n	{\r\n		var exists = false;\r\n		if (!exists)\r\n		{\r\n			details[\"storagetype\"] = \"inline\"; \r\n			exists = Minicore.objectExist(\"modtask\", objectname); \r\n			if (exists && loadtoo)\r\n			{\r\n				if (details[\"unparsed\"] == true)\r\n				{\r\n					details[\"obj\"] = Minicore.getInlineJScriptForObj(objectname); \r\n				}\r\n				else \r\n				{\r\n					details[\"obj\"] = Minicore.loadObject2(modtask, \"modtask\", objectname, false, true);\r\n				}\r\n			}\r\n		}	\r\n		return exists;\r\n	},\r\n\r\n	// todo: include relative pathinformation in the second param 	\r\n	iterateModules : function(context) \r\n	{\r\n		if (typeof(INLINESTORE) == \"object\")\r\n		{\r\n			var p ;\r\n			for(p in INLINESTORE)\r\n			{\r\n				// var name = p.split(\"\\\\\");\r\n				// name = name[name.length-1];			\r\n				var name = p;\r\n				context[\"fn\"](\"\", \"\", name);\r\n			}\r\n		}\r\n	}	\r\n}\r\n"; 
INLINESTORE["kernel\\extstores\\file"] = "\r\nvar modtask =\r\n{\r\n	verbose: {},\r\n   seperator : '/',\r\n	defaultPathsToSearch : [],\r\n	externalPathResolver : false,\r\n	pathCache : {},\r\n	file : false,\r\n	modstr : false,\r\n	getparseerrorinfo : true,\r\n	modsel : false, \r\n	modpath : false,\r\n	extentionstr : \".js\",\r\n	configname : \"kernel\\\\extstores\\\\file\",\r\n \r\n	afterAdd : function(modsel)\r\n	{\r\n		modtask.modsel = modsel;\r\n	},\r\n\r\n	objectExist : function(objectname, details, loadtoo) {\r\n		var exists = false, decodefunc = function(str) { return str; };\r\n		if (!exists) {\r\n			details[\"storagetype\"] = \"file\";\r\n			var pth = modtask.getObjectPath(objectname, true, details);\r\n			if (pth != false)\r\n				exists = modtask.file.FileExists(pth);\r\n			if (exists) {\r\n        details[\"objpath\"] = pth;\r\n        if (loadtoo) {\r\n           if (details[\"unparsed\"] == true) {\r\n	            if (modtask.verbose.loadObject) console.log('loadObject via kernel/extstores/file.objectExist: ' + byname);\r\n              details[\"obj\"] = modtask.file.readFile(pth);\r\n           } else {\r\n              if (modtask.modstr.contains(pth, \"needsobfuscate\")) {\r\n                 modtask.Fail(\"needsobfuscate not implemented\");\r\n              }\r\n              details[\"obj\"] = modtask.loadFromFileParseFunc(modtask, pth, \"modtask\", decodefunc);\r\n           }\r\n        }\r\n			}\r\n		} \r\n		return exists;\r\n	},\r\n\r\n	iterateModules : function(context) \r\n	{\r\n		var tmpcontext1 = {\r\n			\"fn\" : function(a, b, path) {\r\n				if (!modtask.file.folderExists(path)) {\r\n					return;\r\n				}\r\n				var tmpcontext = {\r\n					\"path\" : path,  \r\n					\"fn\" : function(a, b, taskname)\r\n					{\r\n						if ((!modtask.modstr.endsWith(taskname, \"~\")) && modtask.modstr.endsWith(taskname, modtask.extentionstr)) \r\n						{\r\n							taskname = taskname.split(\".\")[0];\r\n							context[\"fn\"](\"\", \"\", taskname);\r\n						}					\r\n					}\r\n				};\r\n				modtask.file.iterateFoldercontent(modtask, tmpcontext);	 \r\n			} \r\n		};\r\n		modtask.iteratePathsToSearch(tmpcontext1);\r\n 	},\r\n\r\n 	getObjectPath : function(byname, dontfailifnotexist, details) {\r\n		if (modtask.verbose.getObjectPath) console.log('getObjectPath', byname);\r\n		var ret = false;\r\n\r\n	  var probePathExists = function(pth) {\r\n		  var exists = modtask.file.FileExists(pth);\r\n		  if (modtask.verbose.getObjectPath) console.log('getObjectPath [' + byname + '], testing: ' + pth + ', exists=' + exists);\r\n		  return exists;\r\n	  }\r\n\r\n 		if (modtask.pathCache[byname]) {\r\n		} else {\r\n			var tmpcontext = {\r\n				\"fn\" : function(a, b, path) {\r\n					ret = modtask.file.pathCombine(path, byname + modtask.determineExtension(byname));\r\n					ret = modtask.kernelpath.normalize(ret);\r\n					if (typeof(details) == \"object\") {\r\n						if (!details[modtask.__myname]) {\r\n							details[modtask.__myname] = { \"chainstr\" : \"\" };\r\n						}\r\n						details[modtask.__myname][\"chainstr\"] += \", \" + ret;\r\n					}\r\n					if (probePathExists(ret)) {\r\n						return \"true\";\r\n					} else {\r\n						ret = false;\r\n					}\r\n				} \r\n			};\r\n		  // if begins with / first check the absolute path exists\r\n		  // If not, then just fall back into searching everything else by removing the front slash\r\n		  if (byname.indexOf('/') == 0) {\r\n			  ret = byname + modtask.determineExtension(byname);\r\n			  ret = modtask.kernelpath.normalize(ret);\r\n			  if (!probePathExists(ret)) {\r\n				  byname = byname.substr(1, byname.length-1);\r\n				  modtask.iteratePathsToSearch(tmpcontext);\r\n			  }\r\n		  } else {\r\n			  modtask.iteratePathsToSearch(tmpcontext);\r\n		  }\r\n			if (ret == false) {\r\n				if (dontfailifnotexist) {\r\n					modtask.pathCache[byname] = false;\r\n				} else {\r\n					modtask.Fail(\"getObjectPath.object not found \" + byname);\r\n				}\r\n			} else\r\n				modtask.pathCache[byname] = ret;\r\n		}\r\n		return modtask.pathCache[byname]; \r\n	},\r\n\r\n	iteratePathsToSearch : function(context) {\r\n		var paths = modtask.defaultPathsToSearch;\r\n		var anchorpath = modtask.getAnchorDirectory();\r\n		if (typeof(modtask.externalPathResolver) == \"function\") {\r\n			paths = modtask.externalPathResolver(modtask);\r\n		} \r\n 		var i, path;\r\n		if (modtask.verbose.iteratePathsToSearch) console.log('iteratePathsToSearch.paths', paths);\r\n		for(i=0; i < paths.length; ++i) {\r\n			path = modtask.modminipath.pathMap(paths[i]);\r\n			if (!modtask.modstr.endsWith(path, modtask.seperator))\r\n				modtask.Fail(\"externalPathResolver has and entry that doesn't end in '\" + modtask.seperator + \"'. Please make sure the entry \" + i + \"(\" + path + \") in thirdparty/config/kernel/extstores/file.js ends with \" + modtask.seperator );\r\n\r\n			if (path.indexOf('rel:') == 0) {\r\n				if (modtask.verbose.iteratePathsToSearch) console.log('iteratePathsToSearch.using anchor path [' + anchorpath + '] for path', path);\r\n				path = path.replace(/^rel:/, '');\r\n				path = modtask.file.pathCombine(anchorpath, path);\r\n			}	\r\n			if (context[\"fn\"](\"\", \"\", path) == \"true\")\r\n				break;\r\n		}\r\n	},	\r\n\r\n	loadModuleInModtaskFromPath : function(_modtask, path, decodefunc)\r\n	{\r\n		if (typeof(decodefunc) != \"function\")\r\n			decodefunc = function(str) { return str; };	\r\n\r\n		var funcs = \r\n		{\r\n			existfunc : function(objecttype, objectname) { return modtask.file.FileExists(objectname); } ,\r\n			parsefunc : function(_modtask, objname, objecttype) { return modtask.loadFromFileParseFunc(_modtask, objname, objecttype , decodefunc); }\r\n		}\r\n		// true means do not validate\r\n		return Kernel.loadModuleInModtask(_modtask, path, true, funcs);\r\n	},\r\n\r\n	// NOTE: Things get messed up when trying to load a modtask with the conflicting properties as ourselves.\r\n	// One example is the config module for us :)\r\n	loadFromFileParseFunc : function(_modtask, objname, objecttype, decodefunc) {\r\n		if (modtask.verbose.loadObject) console.log('loadObject via kernel/extstores/file.loadFromFileParseFunc: [' + objecttype + '] ' + objname);\r\n		var __tempobjstore = \"\";\r\n		try {\r\n			var unparsedstrform = decodefunc(modtask.file.readFile(objname));\r\n			var token = 'izy-loadobject nodejs-require';\r\n			if (typeof(require) == 'function' && unparsedstrform.indexOf('/* ' + token + ' */') > -1) {\r\n				if (require.cache && require.resolve)\r\n					delete require.cache[require.resolve(objname)];\r\n				__tempobjstore = require(objname);\r\n			} else {\r\n				__tempobjstore = Minicore.nakedParseStr(_modtask, objname, objecttype, unparsedstrform);\r\n			}\r\n			__tempobjstore[\"__loadObject2Path\"] = objname;\r\n		} catch(e) {\r\n			var err = \"loadFromFileParseFunc \" + Minicore.newLine;\r\n		        err += \"file   : \" + objname + Minicore.newLine;\r\n			err += \"error  : \" + modtask.exceptionToString(e) + Minicore.newLine;\r\n			err += \"parser : \";\r\n			if (modtask.getparseerrorinfo) {\r\n				err += e.stack;\r\n			}\r\n			_modtask.Fail(err);\r\n		}\r\n 		return __tempobjstore;\r\n	},	\r\n	\r\n	getAnchorDirectory : function() {\r\n		var path = modtask.file.getPathNameFromFullPath(Kernel.getRootPathIfAny());\r\n		if (path.length == 0)\r\n			path = \".\";\r\n		if (path.substr(path.length-1, 1) == modtask.seperator) {\r\n			path = path.substr(0, path.length-1);\r\n		}\r\n 		return path + modtask.seperator + \"modtask\";\r\n	},\r\n\r\n	init : function() {\r\n		modtask.modpath = modtask.ldmod(\"path\");\r\n	   modtask.file = modtask.ldmod(\"file\");	\r\n		modtask.modstr = modtask.ldmod(\"core\\\\string\");\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator;\r\n		modtask.kernelpath = modtask.ldmod('kernel/path');\r\n    modtask.defaultPathsToSearch = [\r\n      'rel:' + modtask.seperator, // anchorpath/modtask\r\n	    'rel:' + modtask.seperator + '..' + modtask.seperator // anchorpath\r\n    ];\r\n	},\r\n \r\n	getDependencies : function(moduleconfig) {\r\n 		var ret = [\r\n		  ['modtask', 'minipath'],\r\n			['modtask', 'file'],\r\n			['modtask', 'path'],\r\n		  ['modtask', 'core\\\\string'],\r\n		  ['modtask', 'kernel/path']\r\n		];\r\n		return ret;\r\n	}		\r\n}\r\n\r\n// We cannot use core/string because ldmod is not available here :(\r\nmodtask.endsWith = function(str1, str2) {\r\n	if (str1.length >= str2.length) {\r\n		if (str1.substr(str1.length-str2.length, str2.length) == str2) return true;\r\n	}\r\n	return false;\r\n};\r\n\r\n//\r\n// Note no ldmod, etc. are allowed. This is a kernel level functionality\r\n//\r\nmodtask.determineExtension = function(basepath) {\r\n	var exclusionList = ['.html', '.css'];\r\n	var i;\r\n	for(i=0; i < exclusionList.length; ++i) {\r\n		var item = exclusionList[i];\r\n		if (modtask.endsWith(basepath, item)) return '';\r\n	}\r\n	return modtask.extentionstr;\r\n}"; 
INLINESTORE["minipath"] = "\nvar modtask = {};\nmodtask.seperator = \"/\";\nmodtask.pathMap = function(path)\n{\n	path = path + \"\";\n	switch(modtask.seperator)\n	{\n		case \"/\" :\n			path = path.replace(/\\\\/g, modtask.seperator);\n			break;\n		case \"\\\\\" :\n			path = path.replace(/\\//g, \"\\\\\");\n			break;\n	}				\n	return path; \n};\nmodtask.init = function()\n{\n	if (modtask.ldmod(\"kernel/plat\").getOSName() == \"windows\")\n	{\n		modtask.seperator = \"\\\\\";\n	};\n}\n\nmodtask.getDependencies = function() { return [['modtask', 'kernel/plat']]; };\n"; 
INLINESTORE["kernel/plat"] = "\nvar modtask = {};\nmodtask.getOSName = function()\n{\n	var ret = 'unix';\n	if (Minicore.rootModule.platform.__myname.indexOf('cscript') > 0)\n		ret = 'windows';\n	return ret; \n};\n"; 
INLINESTORE["file"] = "\r\nvar modtask =\r\n{\r\n	str : false,\r\n   verbose : false, 	\r\n\r\nseperator : \"/\",\r\nnewLine : \"\\r\\n\",\r\n\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\logging\"],\r\n			[\"modtask\", \"minipath\"]\r\n		];\r\n		return ret;\r\n	},\r\n\r\n	init : function()\r\n	{\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator;\r\n\r\n		\r\n		modtask.str = modtask.ldmod(\"core\\\\string\"); \r\n		var _File = modtask.ldmod(Kernel.getModulePath(\"file\"));\r\n		if (_File[\"afterInit\"])\r\n			_File[\"afterInit\"](modtask);\r\n\r\n		modtask.ldmod(\"kernel\\\\logging\").makeVerboseSensitive(modtask);\r\n \r\n		modtask.FileExists = function(path)		\r\n		{\r\n			return _File.FileExists(modtask.modminipath.pathMap(path));\r\n		};\r\n		modtask.folderExists = function(path)\r\n		{\r\n			return _File.folderExists(modtask.modminipath.pathMap(path));\r\n		};\r\n		modtask.mappedCopy = _File.mappedCopy;\r\n		modtask.iterateFilecontent = function(_modtask, context)  \r\n		{\r\n		if (!context[\"path\"])\r\n			_modtask.Fail(\"path not set\");\r\n\r\n		context[\"path\"] = modtask.modminipath.pathMap(context[\"path\"]);\r\n		 _File.iterateFilecontent(_modtask, context);\r\n		};\r\n		modtask.iterateFilecontent2 = function(context) { return modtask.iterateFilecontent(modtask, context); } ;  \r\n\r\n		modtask.iterateFoldercontent = function(_modtask, context)\r\n		{\r\n			if (!context[\"path\"])\r\n				_modtask.Fail(\"iterateFoldercontent.path not set\");\r\n			context[\"path\"] = modtask.modminipath.pathMap(context[\"path\"]);\r\n			return _File.iterateFoldercontent(_modtask, context);\r\n		}\r\n		modtask.iterateFoldercontent2 = function(context) { return modtask.iterateFoldercontent(modtask, context); } \r\n\r\n		modtask.createFolder3 = function(path) { return modtask.createFolder2(modtask, path); } ;\r\n		modtask.createFolder2 = \r\n		function(_modtask, path)\r\n		{	\r\n			path = modtask.modminipath.pathMap(path);\r\n			return _File.createFolder2(_modtask, path);\r\n		};\r\n		modtask.removeFolder = function(_modtask, destdir)\r\n		{\r\n			return _File.removeFolder(_modtask, modtask.modminipath.pathMap(destdir));\r\n		};\r\n		modtask.removeFolder2 = function(path) { return modtask.removeFolder(modtask, path); } ;\r\n\r\n		modtask.getTempFullFilePath = _File.getTempFullFilePath;\r\n		modtask.getTempFullPath = _File.getTempFullPath;		\r\n\r\n		// This is the one that adds \\r\\n at the end \r\n		modtask.writeToTextFile = function(file, str)\r\n		{\r\n			return modtask.writeFile(file, str + modtask.newLine);\r\n		}\r\n\r\n		 // This is the good one \r\n		modtask.writeFile = function(file, str)\r\n		{\r\n			return _File.writeFile(modtask.modminipath.pathMap(file), str);\r\n		}\r\n	\r\n		modtask.deleteFile = function(path) { return _File.deleteFile(modtask.modminipath.pathMap(path)); } ;\r\n		modtask.readFileEx = function(_modtask, path, absolute)\r\n		{\r\n			path = modtask.modminipath.pathMap(path);\r\n			return _File.readFileEx(_modtask, path, absolute);\r\n		};\r\n\r\n		modtask.readFile = function(path) { return modtask.readFileEx(modtask, path, true); } ;  \r\n		modtask.appendToFile = function(path, str)\r\n		{\r\n			return _File.appendToFile(modtask.modminipath.pathMap(path), str);\r\n		}\r\n		modtask.MoveFile = function(_modtask, src, dst)\r\n		{\r\n			return _File.MoveFile(_modtask, modtask.modminipath.pathMap(src), modtask.modminipath.pathMap(dst));\r\n		}\r\n		modtask.MoveFile2 = function(src, dest) { return _File.MoveFile(modtask, src, dest); };\r\n\r\n		modtask.fileCreatedInDir = _File.fileCreatedInDir;\r\n	},\r\n\r\n	// Will forcefully write file. Createfolder if not exists\r\n	forceWriteFile : function(fullpath, content)\r\n	{\r\n		fullpath = modtask.modminipath.pathMap(fullpath);\r\n 		var folder = modtask.getPathNameFromFullPath(fullpath);\r\n		if (!modtask.folderExists(folder))\r\n			modtask.createFolder3(folder);\r\n		return modtask.writeFile(fullpath, content); 		\r\n	},\r\n\r\n	getTempDir : function()\r\n	{\r\n		return modtask.getPathNameFromFullPath(modtask.getTempFullFilePath(\"prefix\"));\r\n	},	\r\n\r\n	copy : function(fullsourcepath, destdir, destfilename)\r\n	{\r\n		fullsourcepath = modtask.modminipath.pathMap(fullsourcepath);\r\n		destdir = modtask.modminipath.pathMap(destdir);\r\n\r\n		var srcpath = modtask.getPathNameFromFullPath(fullsourcepath);\r\n		var srcname = modtask.getFilenameFromFullPath(fullsourcepath);\r\n		var map = {};\r\n		if (!destfilename)\r\n			destfilename = srcname;\r\n		map[srcname] = destfilename;\r\n		return modtask.mappedCopy(map, srcpath, destdir);\r\n	},\r\n \r\n\r\n	generateFileFromTemplate : function(_modtask, templatefile, outputfile, tokens)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n\r\n		templatefile = modtask.modminipath.pathMap(templatefile);\r\n		outputfile = modtask.modminipath.pathMap(outputfile);\r\n\r\n\r\n		modtask.Log(\"generating \" + outputfile);\r\n		var content = modtask.readFileEx(modtask, templatefile, true);			\r\n		modtask.writeToTextFile(outputfile, modstr.replaceTokens(content, tokens));		\r\n	},	\r\n\r\n	getFilenameFromFullPath : function(fullpath)\r\n	{\r\n		fullpath = modtask.modminipath.pathMap(fullpath);\r\n		var tmp = fullpath.split(modtask.seperator);\r\n		return tmp[tmp.length-1];\r\n	},	\r\n\r\n	// we cannot reference this back to kerne\\\\path -- because of the chain loader \r\n	getPathNameFromFullPath : function(fp)\r\n	{\r\n		fp = modtask.modminipath.pathMap(fp);\r\n		var ret = \"\", i=0;\r\n		var tmp = fp.split(modtask.seperator);\r\n		for(i=0; i < tmp.length - 1; ++i)\r\n			ret += tmp[i] + modtask.seperator;\r\n		return ret;  \r\n	},\r\n\r\n	pathCombine : function(path1, path2)\r\n	{\r\n		path1 = modtask.modminipath.pathMap(path1);\r\n		path2 = modtask.modminipath.pathMap(path2);\r\n\r\n\r\n		if (typeof(path1) != \"string\" || typeof(path2) != \"string\")\r\n			modtask.Fail(\"pathCombine: path1 or path2 nonstrings\");\r\n\r\n		if (path1.length == 0)\r\n			return path2;\r\n		if (path2.length == 0)\r\n			return path1;\r\n\r\n		var ret = path1 + modtask.seperator + path2 + modtask.seperator;\r\n		ret = modtask.strCleanDoubleBackSlash(ret, modtask.seperator);\r\n		if (ret.substr(ret.length-1, 1).indexOf(modtask.seperator) == 0)\r\n			ret = ret.substr(0, ret.length-1);\r\n		return ret;\r\n	},\r\n\r\n	emptyFolder : function(path)\r\n	{\r\n		modtask.removeFolder2(path);\r\n		modtask.createFolder3(path); \r\n	},		\r\n\r\n	// jscript regex bug: 	ret.replace(/\\\\\\\\/g, \"\\\\\") does not work!!!\r\n	strCleanDoubleBackSlash : function(str, rpl)\r\n	{\r\n		var dbl = modtask.seperator + modtask.seperator;\r\n		while(str.indexOf(dbl) >= 0)\r\n			str = str.replace(dbl, rpl);\r\n		return str;\r\n	},\r\n\r\n\r\n	 \r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\logging\"],\r\n			[\"modtask\", \"minipath\"] \r\n		];\r\n		return ret;\r\n	}\r\n}\r\n"; 
INLINESTORE["kernel\\logging"] = "\r\nvar modtask = \r\n{\r\n	makeVerboseSensitive : function(mod)\r\n	{\r\n		if (typeof(mod[\"verbose\"]) == \"boolean\")\r\n		{\r\n			mod[\"tmplog\"] =mod[\"Log\"];\r\n			mod[\"Log\"] = function(x, doit, dontloop) { if (doit || mod[\"verbose\"] == true) return mod[\"tmplog\"](x, doit); } \r\n		}\r\n	}\r\n}\r\n"; 
INLINESTORE["path"] = "\r\nvar modtask = \r\n{\r\n	getRelativePath : function(fullPath, rootPath)\r\n	{\r\n		if (typeof(fullPath) != \"string\")\r\n			modtask.Fail(\"getRelativePath  fullPath\");\r\n\r\n		if (typeof(rootPath) != \"string\")\r\n			modtask.Fail(\"getRelativePath  rootPath\");\r\n	\r\n		if (rootPath.length == 0)\r\n			return fullPath;\r\n\r\n		// On windows, drive is optional, so make sure that the drive is present on both strings \r\n		if (fullPath.indexOf(\":\") < 0)\r\n			fullPath = \"x:\" + fullPath;\r\n		if (rootPath.indexOf(\":\") < 0)\r\n			rootPath = \"x:\" + rootPath;\r\n\r\n		fullPath = fullPath.substr(2, fullPath.length-2);\r\n		rootPath = rootPath.substr(2, rootPath.length-2);\r\n\r\n		if (!modtask.modstr.startsWith(fullPath, rootPath))\r\n		{\r\n			// It could be because of ..\r\n			fullPath = this.eliminateDoubleDot(fullPath);	\r\n			rootPath = this.eliminateDoubleDot(rootPath);	\r\n		}\r\n\r\n		var prefix = \"\";var origroot = rootPath;\r\n		while(!modtask.modstr.startsWith(fullPath, rootPath) && rootPath.length > 0)\r\n		{\r\n			prefix = \"\\\\..\" + prefix;\r\n			// Shift-up\r\n			rootPath = modtask.moveUp(rootPath);\r\n		} \r\n\r\n		if (rootPath.length < 1)\r\n		{\r\n			modtask.Fail(\"getRelativePath impossible conversion for '\" + fullPath + \"' / '\" + origroot + \"'\");\r\n		} \r\n\r\n		if (!modtask.modstr.endsWith(rootPath, \"\\\\\"))\r\n			rootPath = rootPath + \"\\\\\";\r\n		var ret = fullPath.substr(rootPath.length, fullPath.length-rootPath.length);\r\n		return prefix + \"\\\\\" + this.eliminateDoubleDot(ret);			\r\n	},\r\n\r\n	moveUp : function(path)\r\n	{\r\n		if (modtask.modstr.endsWith(path, \"\\\\\"))\r\n			path = path.substr(0, path.length-1);\r\n 		var pth = path.split(\"\\\\\");\r\n		var i;\r\n		var ret = \"\";\r\n		for(i=0; i < pth.length-1; ++i)\r\n		{\r\n			ret = ret + pth[i] + \"\\\\\";\r\n		} \r\n		if (ret.length > 1)\r\n			ret = ret.substr(ret, ret.length-1);\r\n\r\n		return ret; \r\n	},		\r\n\r\n	eliminateDoubleDot : function(path)\r\n	{\r\n		var pth = path.split(\"\\\\\");\r\n		var i;\r\n		var ret = \"\";\r\n		for(i=0; i < pth.length; ++i)\r\n		{\r\n			if (i+1 < pth.length && pth[i+1] == \"..\")\r\n			{\r\n				i+=1;\r\n				continue;\r\n			}\r\n			ret = ret + pth[i] + \"\\\\\";\r\n		} \r\n		ret = ret.substr(ret, ret.length-1);\r\n		return ret;\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n   		var ret =  [\r\n			[\"modtask\", \"core\\\\string\"] \r\n		];\r\n 		return ret;		\r\n	},\r\n\r\n	init : function()\r\n	{\r\n		modtask.modstr = modtask.ldmod(\"core\\\\string\");\r\n	}\r\n}\r\n"; 
INLINESTORE["kernel/path"] = "\r\nvar modtask = \r\n{\r\n	up : \"..\\\\\",\r\n	get : function(fp, depth) {\r\n		var ret = \"\", i=0;\r\n		var tmp = fp.split(\"\\\\\");\r\n		if (tmp.length - depth < 0)\r\n		{\r\n			for(i=0; i > tmp.length - depth; --i)\r\n				ret += modtask.up; \r\n		}\r\n		else \r\n		{\r\n			for(i=0; i < tmp.length - depth; ++i)\r\n				ret += tmp[i] + \"\\\\\";\r\n		}\r\n		return ret; \r\n	},\r\n\r\n	parse : function(path) {\r\n		return modtask.normalize(path);\r\n	},\r\n\r\n	normalize : function(path) {\r\n		path = path + '';\r\n		var slashbased = path.indexOf('/') >= 0;\r\n		if (slashbased) {\r\n			path = path.replace(/\\//g, '\\\\');\r\n		}\r\n		path = path.replace(/[A-Za-z0-9-]+\\\\\\.\\.\\\\/g, '');\r\n		if (slashbased) {\r\n			path = path.replace(/\\\\/g, '/');\r\n		}\r\n		return path; \r\n	},		\r\n\r\n	rel : function(rp, modulenameOrMod, useModuleContextForPath) {\r\n		var modulename = modulenameOrMod;\r\n		if (useModuleContextForPath) {\r\n			if (modulenameOrMod.__contextualName) {\r\n				modulename = modulenameOrMod.__contextualName;\r\n			} else {\r\n				modulename = modulenameOrMod.__myname;\r\n			}\r\n		}\r\n\r\n		if (!modulename) modulename = modtask.__modtask.__myname;\r\n		\r\n		var slashbased = (rp.indexOf('/') >= 0 || modulename.indexOf('/') >= 0);\r\n		rp = rp.replace(/\\//g, \"\\\\\"); \r\n		modulename = (modulename+\"\").replace(/\\//g, \"\\\\\"); \r\n \r\n 		var depth = 1;\r\n		while(rp.indexOf(modtask.up) == 0) {\r\n			rp = rp.substr(modtask.up.length, rp.length - modtask.up.length);\r\n			depth++;\r\n		} \r\n		var base = modtask.get(modulename, depth); \r\n		base = base + rp; \r\n		base = base.replace(/\\//g, \"\\\\\"); \r\n	  base = modtask.parse(base);\r\n		if (slashbased) {\r\n			base = base.replace(/\\\\/g, '/');\r\n		}\r\n		return base;\r\n   },\r\n\r\n   resolve : function(modulenameOrMod, depname, useModuleContextForPath) {\r\n      if (depname == \"_data\") {\r\n         depname = modtask.rel(\"data\", modulenameOrMod);\r\n      }\r\n      else if (depname.indexOf(\"rel:\") == 0) {\r\n         depname = modtask.rel(depname.substr(4, depname.length-4),\r\n	         modulenameOrMod,\r\n	         useModuleContextForPath);\r\n      }\r\n	   return depname;\r\n   }     \r\n}\r\n\r\nmodtask.parseInvokeString = function(path) {\r\n	var pkg = '';\r\n	if (path.indexOf(':') >= 0) {\r\n		pkg = path.split(':');\r\n	};\r\n	var mod, params = '';\r\n	if (pkg.length) {\r\n		mod = pkg[0] + '/' + pkg[1];\r\n		pkg = pkg[0];\r\n		params = path.substr(mod.length+1);\r\n	} else {\r\n		pkg = '';\r\n		mod = path;\r\n		params = '';\r\n	}\r\n	return { path: path, pkg: pkg, mod: mod, params: params };\r\n}\r\n\r\nmodtask.toInvokeString = function(path, _modToPkgMap) {\r\n	if (!path) path = modtask.__modtask.__myname;\r\n	if (path.indexOf(\"rel:\") == 0) path = modtask.rel(path.substr(4, path.length-4));\r\n	// already in the pkg:view/top format\r\n	if (path.indexOf(':') > 0) {\r\n		return {\r\n			success: true,\r\n			data: path\r\n		};\r\n	}\r\n\r\n	var maps = [\r\n		modtask.ldmod('kernel/mod').ldonce('kernel/extstores/import').modToPkgMap,\r\n		_modToPkgMap\r\n	];\r\n\r\n	for (var q in maps) {\r\n		try {\r\n			var map = maps[q] || {};\r\n			var p;\r\n			for (p in map) {\r\n				if (p == path || p.replace(/:/g) == path) {\r\n					var pkg = map[p];\r\n					path = path.substr(pkg.length + 1);\r\n					path = pkg + ':' + path;\r\n					return {\r\n						success: true,\r\n						data: path\r\n					}\r\n				}\r\n			}\r\n		} catch (e) {\r\n			return {\r\n				success: false,\r\n				reason: 'There was an error using kernel/extstores/import modToPkgMap. Make sure kernerl/extstores/import is available.'\r\n			};\r\n		}\r\n	}\r\n	return {\r\n		success: false,\r\n		reason: '[toInvokeString] Cannot determine package name for \"' + path + '\" automatically.'\r\n	};\r\n}\r\n\r\n"; 
INLINESTORE["host\\nodejs\\file"] = "\r\nvar modtask = \r\n{\r\n	fso : false,\r\n	filemod : false,\r\n	commonmod : false,\r\n	ForReading : 1,	\r\n\r\n	seperator : \"/\",\r\n	newLine : \"\\r\\n\",\r\n\r\n	init : function()\r\n	{\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator;\r\n\r\n		modtask.fso = require('fs');\r\n		modtask.commonmod = modtask.ldmod(\"host\\\\nodejs\\\\filecommon\");\r\n	},\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.commonmod.afterInit(_filemod);\r\n		modtask.filemod = _filemod;\r\n		modtask.fileCreatedInDir = modtask.commonmod.fileCreatedInDir;\r\n	},\r\n\r\n 	createFolder2 : function(_modtask, path)\r\n	{\r\n		var i;\r\n		var pth = path.split(modtask.seperator);\r\n		var pthtocreate = \"\";\r\n		for(i=0; i < pth.length; ++i)\r\n		{\r\n			pthtocreate += pth[i] + modtask.seperator ;\r\n			if (!modtask.folderExists(pthtocreate))\r\n			{\r\n				modtask.fso.mkdirSync(pthtocreate);\r\n			}\r\n			else\r\n			{	\r\n			}\r\n		}			\r\n	}, \r\n\r\n	iterateFilecontent : function(_modtask, context)  \r\n	{\r\n		if (!modtask.FileExists(context[\"path\"]))\r\n			modtask.Fail(\"iterateFilecontent: file not exist \" + context[\"path\"]);\r\n\r\n		var f = modtask.readFileEx(_modtask, context[\"path\"], true);\r\n		var lnno = 0;\r\n		var newln;\r\n		f = f.split(\"\\n\");\r\n		while (lnno < f.length)\r\n		{\r\n			newln = f[lnno];\r\n			lnno++;\r\n			if (context[\"fn\"](lnno, \"\", newln) == \"break\")\r\n				break;\r\n		}\r\n	},	\r\n\r\n	removeFolder : function(_modtask, destdir)\r\n	{\r\n		var fs = modtask.fso;\r\n		var deleteFolderRecursive = function(path) {\r\n		  if( fs.existsSync(path) ) {\r\n		    fs.readdirSync(path).forEach(function(file,index){\r\n		      var curPath = path + modtask.seperator + file;\r\n		      if(fs.lstatSync(curPath).isDirectory()) { // recurse\r\n			deleteFolderRecursive(curPath);\r\n		      } else { // delete file\r\n				fs.unlinkSync(curPath);\r\n		      }\r\n		    });\r\n		    fs.rmdirSync(path);\r\n		  }\r\n		}; \r\n		deleteFolderRecursive(destdir);\r\n	},	\r\n\r\n	getTempFullFilePath : function(prefix)\r\n	{\r\n		if (!prefix)\r\n			prefix = \"\";\r\n		return modtask.getTempFullPath() +  prefix + modtask.getTempFilename();\r\n	},\r\n\r\n	getTempFullPath : function()\r\n	{\r\n		var ret = require('os').tmpdir();\r\n		if (!ret.match(/\\/$/)) ret += modtask.seperator;\r\n		return ret;\r\n	},		\r\n\r\n	getTempFilename : function()\r\n	{\r\n		return 'nodejs_temp_' + new Date().getTime() + Math.round(Math.random() * 1000000);\r\n	},\r\n\r\n	writeFile : function(file, str)\r\n	{\r\n		return modtask.fso.writeFileSync(file, str);\r\n	},		\r\n\r\n	readFileEx : function(_modtask, name, absolute)\r\n	{\r\n		var path = name;\r\n\r\n		if (!absolute)\r\n			modtask.Fail(\"readFileEx.nonabsolutenotsupported\"); \r\n		if (!modtask.FileExists(path))\r\n			modtask.Fail(\"readFileEX on non existent file: \" + path);\r\n\r\n		try \r\n		{\r\n			var ret = modtask.fso.readFileSync(path).toString(); \r\n			return ret; \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"readFileEx '\" + path + \"': \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	appendToFile : function(path, str)\r\n	{\r\n		modtask.fso.appendFileSync(path, str + modtask.newLine);	\r\n	},\r\n\r\n	folderExists : function(path)\r\n	{\r\n		return modtask.FileExists(path, true);\r\n	},\r\n	\r\n\r\n	FileExists : function(path, checkFordir)		\r\n	{ 	\r\n		var outcome = false;\r\n		try {\r\n		    stats = modtask.fso.lstatSync(path);\r\n		    if (checkFordir)\r\n			outcome = stats.isDirectory();\r\n		    else \r\n			outcome = stats.isFile();\r\n		}\r\n		catch (e) { \r\n		}\r\n		return outcome;\r\n	},\r\n	\r\n\r\n	deleteFile: function(path)\r\n	{\r\n		if (!modtask.FileExists(path))\r\n			return ;\r\n		modtask.fso.unlinkSync(path);\r\n	},\r\n\r\n\r\n	mappedCopy : function(map, rootdir, destdir)\r\n	{\r\n		modtask.Fail('Mapped copy moved to deploy/copy');	\r\n	},\r\n\r\n	MoveFile : function(_modtask, src, dst)\r\n	{\r\n	       	if (!modtask.FileExists(src))\r\n			modtask.Fail(\"source.file.not.exists '\" + src + \"'\");		\r\n		var name = modtask.filemod.getFilenameFromFullPath(src);\r\n\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		var dest;\r\n		if (modstr.startsWith(dst, \"file:\"))\r\n			dest = dst.substr(5, dst.length-5);\r\n		else \r\n			dest = modtask.filemod.pathCombine(dst, name);\r\n\r\n		try\r\n		{	\r\n			modtask.fso.renameSync(src, dest);  \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"modtask.fso.renameSync \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	iterateFoldercontent : function(_modtask, context)\r\n	{\r\n		if (!context[\"path\"])\r\n			_modtask.Fail(\"iterateFoldercontent.path not set\");\r\n\r\n      if (!context[\"method\"])\r\n         context[\"method\"] = \"shallow\";         \r\n\r\n		var dir = context[\"path\"];\r\n\r\n		if (!modtask.folderExists(dir))\r\n			_modtask.Fail(\"iterateFoldercontent on non existent dir: \" + dir);\r\n\r\n	// 	var srcFolder = modtask.fso.readdirSync( dir );    	\r\n		var files = modtask.fso.readdirSync( dir );    \r\n	        files.map(function(_item)\r\n				{\r\n\r\n 	\r\n					_item += \"\";\r\n			var fname = modtask.filemod.getFilenameFromFullPath(_item); \r\n			context[\"fn\"](\"\", \"\", fname, dir, _item);\r\n				}); \r\n\r\n      if (context[\"method\"] == \"deep\")\r\n      {\r\n	      modtask.Fail('DEEEP_HAS_NOT_BEEN_IMPLEMENTED');\r\n          var subFlds = new Enumerator(srcFolder.SubFolders);\r\n          var s = \"\";\r\n          for (; !subFlds.atEnd(); subFlds.moveNext()) \r\n          {\r\n             context[\"path\"] = subFlds.item() + \"\";\r\n             modtask.iterateFoldercontent(_modtask, context);\r\n          }\r\n      }      \r\n	},	\r\n\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"os\\\\windows\\\\filecommon\"]\r\n		];\r\n		return ret;\r\n	}	\r\n	\r\n}\r\n"; 
INLINESTORE["proc"] = "\r\nvar modtask = \r\n{\r\n	runApp : false,\r\n	str : false,\r\n	file : false,\r\n\r\n	runAppAndFailIfneeded : function(s, channel, outputstr, _modtask, shouldnotexist, logoutput, async, returnexitcode)\r\n	{\r\n		var rt = modtask.runApp(s, false, async);\r\n		var res;\r\n\r\n		if (returnexitcode && !async)\r\n			return rt[\"ExitCode\"];\r\n		\r\n		if (channel == \"all\")\r\n			res = rt[\"StdErr\"] + \" \" + rt[\"StdOut\"];\r\n		else \r\n			res= rt[channel];\r\n\r\n		if (rt.StdErr && rt.StdErr.toUpperCase().indexOf(\"IS NOT RECOGNIZED AS AN INTERNAL OR EXTERNAL COMMAND\") >= 0 )\r\n			_modtask.Fail(rt.StdErr);\r\n		\r\n		if (logoutput)\r\n			_modtask.Log(res);\r\n\r\n		if (!outputstr)\r\n			return res;\r\n		if (shouldnotexist)\r\n		{\r\n			if (res.indexOf(outputstr) >=0)\r\n				_modtask.Fail(\"Error running app\\n\" + s + \": '\" + res + \"'\");\r\n			else \r\n				return res;\r\n		}\r\n		else \r\n		{\r\n			if (res.indexOf(outputstr) < 0)\r\n				_modtask.Fail(\"Error running app\\n\" + s + \": '\" + res + \"'\");\r\n			else \r\n				return res;\r\n		}\r\n	},\r\n\r\n	runGUIApp : function(s, visible, async)\r\n    	{\r\n		modtask.rawRun(s, visible, async); 		\r\n	},	\r\n\r\n	init : function()\r\n	{\r\n		modtask.file = modtask.ldmod(\"file\");\r\n		modtask.str = modtask.ldmod(\"core\\\\string\");\r\n		var _Proc = modtask.ldmod(Kernel.getModulePath(\"proc\"));\r\n		if (_Proc[\"afterInit\"])\r\n			_Proc[\"afterInit\"](modtask); \r\n  		modtask.getBinPath = _Proc.getBinPath;\r\n		modtask.createProcess = function(s, visible, async) { return modtask.runGUIApp(s, visible, async);} \r\n	        modtask.rawRun = _Proc.rawRun;\r\n	        modtask.runApp = _Proc.runApp;		\r\n		modtask.getEnvironmentVariable = _Proc.getEnvironmentVariable;\r\n		modtask.constructShellCmdline = _Proc.constructShellCmdline;\r\n	},\r\n \r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n 	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"file\"]	\r\n		];\r\n		return ret;\r\n	}	\r\n}\r\n"; 
INLINESTORE["os\\windows\\filecommon"] = "\r\nvar modtask = \r\n{\r\n	filemod : false,\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.filemod = _filemod;\r\n	},	\r\n\r\n	fileCreatedInDir : function(dir, ext, blocking, timeout)\r\n	{\r\n		var proc = modtask.ldmod(\"proc\");\r\n		var filecreated = false;\r\n		var tmp = \"\";\r\n		var cmd = \"cmd /c dir /b \" + dir + \"\\\\*.\" + ext;\r\n		var time = 0 ;\r\n		var delta = 1000;\r\n\r\n		do \r\n		{\r\n			tmp = proc.runApp(cmd)[\"StdOut\"].replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/ */, \"\");\r\n			filecreated = tmp.length > 0;\r\n			if (filecreated)\r\n				break;	\r\n			if (!blocking || (time > timeout))\r\n				return false;\r\n 			modtask.Log(\"Waiting for .\" + ext + \" in \" + dir + \" t = \" + time + \"/\" + timeout);\r\n			time += delta;\r\n			modtask.Sleep(delta);			\r\n		} while(!filecreated);\r\n		filecreated = modtask.filemod.pathCombine(dir, tmp);\r\n		return filecreated;\r\n	},\r\n\r\n	search : function(_modtask, context)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		if (!context[\"expr\"])\r\n			_modtask.Fail(\"cotext.expr is null\");\r\n		var proc = modtask.ldmod(\"proc\");		\r\n		var ret = proc.runApp(\"dir /s/b/A-D \\\"\" + context.expr + \"\\\"\")[\"StdOut\"].split(\"\\n\");\r\n		var i;\r\n		for(i=0; i < ret.length; ++i)\r\n		{\r\n			ret[i]=ret[i].replace(/^\\s+/g, \"\");\r\n			ret[i] = modstr.strClean1013(ret[i],\"\");			\r\n			if (ret[i].length > 0)\r\n				context.fn(i, \"\", ret[i]);\r\n		}\r\n	},	\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"]	\r\n		];\r\n		return ret;\r\n	} \r\n}\r\n"; 
INLINESTORE["host\\nodejs\\filecommon"] = "\r\nvar modtask = \r\n{\r\n	filemod : false,\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.filemod = _filemod;\r\n	},	\r\n\r\n	fileCreatedInDir : function(dir, ext, blocking, timeout)\r\n	{\r\n		var proc = modtask.ldmod(\"proc\");\r\n		var filecreated = false;\r\n		var tmp = \"\";\r\n		var cmd = \"cmd /c dir /b \" + dir + \"\\\\*.\" + ext;\r\n		var time = 0 ;\r\n		var delta = 1000;\r\n\r\n		do \r\n		{\r\n			tmp = proc.runApp(cmd)[\"StdOut\"].replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/ */, \"\");\r\n			filecreated = tmp.length > 0;\r\n			if (filecreated)\r\n				break;	\r\n			if (!blocking || (time > timeout))\r\n				return false;\r\n 			modtask.Log(\"Waiting for .\" + ext + \" in \" + dir + \" t = \" + time + \"/\" + timeout);\r\n			time += delta;\r\n			modtask.Sleep(delta);			\r\n		} while(!filecreated);\r\n		filecreated = modtask.filemod.pathCombine(dir, tmp);\r\n		return filecreated;\r\n	},\r\n\r\n	search : function(_modtask, context)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		if (!context[\"expr\"])\r\n			_modtask.Fail(\"cotext.expr is null\");\r\n		var proc = modtask.ldmod(\"proc\");		\r\n		var ret = proc.runApp(\"dir /s/b/A-D \\\"\" + context.expr + \"\\\"\")[\"StdOut\"].split(\"\\n\");\r\n		var i;\r\n		for(i=0; i < ret.length; ++i)\r\n		{\r\n			ret[i]=ret[i].replace(/^\\s+/g, \"\");\r\n			ret[i] = modstr.strClean1013(ret[i],\"\");			\r\n			if (ret[i].length > 0)\r\n				context.fn(i, \"\", ret[i]);\r\n		}\r\n	},	\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"]	\r\n		];\r\n		return ret;\r\n	} \r\n}\r\n"; 


var Minicore = {
	verbose: {},
	ERR_DOESNOT_EXIST 	: "Does not exist",
 	newLine : "\r\n",
	rootModule : false,
	isInlineFlat : false,
	loadObjectOverwrite : false,

	doOutcomeException : function(msg) {
		var hash = {};
		hash["message"] = msg;
		throw hash;
	},

 	EncodeFailStr : function(msg) {
		return "FAIL, " + msg;
	},

	toStringIfNeeded : function(res)
	{
		var rt = "";
		var p;
		if (typeof(res) == "object") 
		{
			for(p in res)
			{
				rt += "\r\n" + p + ": " + res[p];
			}
		}
		else 
		{
			try { rt = res + ""; } catch(e) { rt = "toStringIfNeeded.failed on " + typeof(res); };
		}
		return rt;
	},	

	Log : function(msg)
	{
  	},		
	
	Fail : function(msg)
	{
		msg = Minicore.toStringIfNeeded(msg);			
		msg = Minicore.EncodeFailStr(msg);
		Minicore.doOutcomeException(msg);
	},

	Sleep : function(miliseconds)
	{
 	},	

	loadModuleInModtask : function(modtask, modulename, donotvalidate, funcs, dontcallinit) {
		if (Minicore.verbose.loadObject) console.log('loadModuleInModtask', modulename);
		var mod = Minicore.loadModule(modulename, modtask, true, funcs);
 		Minicore.inheritFromModtask(modtask, mod);
		return Minicore.postLoadModule(modtask, mod, dontcallinit);
	},

	postLoadModule : function(modtask, mod, dontcallinit) {
 		mod["ldmod"] = function(x) {
		  if (x.indexOf('./') == 0) {
			  x = x.replace('./', 'rel:');
		  }
		  if (x.indexOf("rel:") == 0) return mod.ldmod(mod.ldmod('kernel/path').resolve(mod, x, true));
		  else return Kernel.loadModuleInModtask(mod, x); 
	  };
		mod["__modtask"] = modtask;			
		mod["sp"] = function(p,v) { 
			var p1;if (typeof(p) == "object") { for(p1 in p) mod["sp"](p1, p[p1]); return mod; }  
			mod[p] = v; return mod; 
		};
		mod["setProp"] = mod["sp"];
		if (mod["Log"]) {
			mod["Log"] = function(x) { Kernel.Log(x); };	
	//		if (!mod["__logname"]) mod["__logname"] = "";
		//	mod["Log"] = function(x) { return modtask.Log(mod["__logname"] + " " + x); } 							
		}
		if (typeof(mod["init"]) == "function")
		{
			if (dontcallinit) { } else { mod["init"]();} 
		}
 		return mod;
	},		

	inheritFromModtask : function(modtask, mod)
	{	 
		var names = ["Log", "Fail", "Sleep", "exceptionToString", "doOutcomeException"];
		var i=0;
		for(i=0; i < names.length; ++i) 
			mod[names[i]] = modtask[names[i]];
	},

	loadModule : function(_modtask, modulename, compatparam, funcs) {
		// support modulename, donotvalidate, modtask 
		if (typeof(_modtask) == "string") {
			// Old format 
			var t = modulename;
			modulename = _modtask;
			_modtask = t;
		}

		if (Minicore.verbose.loadObject) console.log('loadModule [' + modulename + '], loadObjectOverwrite = ' +  (Minicore.loadObjectOverwrite && true));

		if (!_modtask) {
			_modtask = Minicore;
		}

		if (Minicore.loadObjectOverwrite == false) {
			return Minicore.loadObject2(_modtask, "modtask", modulename, false, true, funcs);
		} else {
			return Minicore.loadObjectOverwrite(_modtask, "modtask", modulename, false, true, funcs);
		}
	},

	loadObject2 : function(_modtask, objecttype, objectname, inithash, donotcallinit, funcs) {
		Minicore.flattenTheInlines();
		if (typeof(funcs) != "object")
			funcs = {};
		if (typeof(funcs["existfunc"]) != "function")
			funcs["existfunc"] = Minicore.objectExist;

		if (typeof(funcs["parsefunc"]) != "function")
			funcs["parsefunc"] = Minicore.miniParseObj;		

 		if (!funcs["existfunc"](objecttype, objectname)) {
 			_modtask.Fail(Minicore.EncodeDecode_encodeErrorMessage("loadObject2", Minicore.ERR_DOESNOT_EXIST, objectname));  
			return ;
		}
		return Minicore.rawLoadObject(_modtask, objecttype, objectname, funcs["parsefunc"]); 
	},

	rawLoadObject : function(_modtask, objecttype, objectname, parsefunc) {
		if (Minicore.verbose.loadObject) console.log('rawLoadObject', objectname);
		var retObj = {};
		var __loadObject2Path = "";
		__loadObject2Path = objectname;
		retObj = parsefunc(_modtask, objectname, objecttype);
		if (typeof(retObj["__loadObject2Path"]) != "string")
			retObj["__loadObject2Path"] = __loadObject2Path;
		if (typeof(retObj["__myname"]) != "string")
			retObj["__myname"] = objectname;
		return retObj;
	},

	flattenTheInlines : function()
	{
		if (Minicore.isInlineFlat)
			return ;

		Minicore.isInlineFlat = true;
		if (typeof(INLINESTORE) == "object")
		{
			var p ;
			for(p in INLINESTORE)
			{
				var name = p.split("\\");
				name = name[name.length-1];
				if (!INLINESTORE[name]) 
				{
					// Do not override something else !
					INLINESTORE[name] = INLINESTORE[p];
				}
			}
		}		
	},		

	objectExist : function(objecttype, objectname) {
		var __tempobjstore;
		try {
			eval("__tempobjstore = " + Minicore.getObjectInlineVar(objectname));
		} catch(e) {
			return false;
		}
		return typeof(__tempobjstore) == "string";
	},	

	JscriptToAA : function(modtask, JS, objstoredname) {
		var objcontents;
		try {
			eval(JS + "; objcontents = " + objstoredname + ";");	
		} catch(e) {
			modtask.Fail("JscriptToAA: eval failed on '" + objstoredname +"' :" +  e.description); 
		}
		return objcontents;
	},

	nakedParseStr : function(modtask, objname, objecttype, unparsedstrform) {
		var __tempobjstore = "";
		if (!objecttype)
			objecttype = "modtask";
		if (!unparsedstrform)
			unparsedstrform = Minicore.getInlineJScriptForObj(objname);
		__tempobjstore = unparsedstrform; 
		__tempobjstore = Minicore.JscriptToAA(modtask, __tempobjstore, objecttype); 		
		return __tempobjstore;
	},

	miniParseObj : function(modtask, objname, objecttype, unparsedstrform) {
		try {
			return Minicore.nakedParseStr(modtask, objname, objecttype, unparsedstrform);
		} catch(e) {
			modtask.Fail("miniParseObj failed to parse '" + objname + "' from inlines. ");  
		}
	},

	getInlineJScriptForObj : function(objname) {
		var __tempobjstore = ""; 
		eval("__tempobjstore = Minicore.decodeObjectStrForStorage(" + Minicore.getObjectInlineVar(objname) + ", objname);");
		return __tempobjstore;
	},

	decodeObjectStrForStorage : function(str) {
		return str;
	},

	getObjectInlineVar : function(objectname)
	{
		return "INLINESTORE[\"" + Minicore.EncodeDecode_encodeStringToJSStr(objectname) + "\"]";
	},

	EncodeDecode_encodeErrorMessage : function(action, errormsg, context)
	{
		return action + ", " + errormsg + ": " + context;
	},

	EncodeDecode_encodeStringToJSStr : function(str)
	{
		str = str.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
		var strs = {};

		strs[Minicore.newLine] = "\\" + "r" + "\\" + "n";
		strs["\r"] = "\\" + "r"; 
		strs["\n"] = "\\" + "n";

		var p;
		for(p in strs)
		{
			while (str.indexOf(p) >= 0)
				str = str.replace(p, strs[p]);
		}
		return str;
	}
};


var Kernel=Minicore;

function onSystemStart(platobject)
{
	var p=false;for(p in INLINESTORE) { break; };
	if (p)
	{
		Kernel.rootModule = Kernel.loadModuleInModtask(Kernel, p);
		return Kernel.rootModule.servicecallback("systemstart", platobject);
	}	
} 




onSystemStart();module.exports=Kernel;