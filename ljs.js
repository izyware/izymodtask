

var INLINESTORE = {};INLINESTORE["minicore"] = "\nvar modtask = \n{\n	platform : false,\n	usermodule : false,\n\n	// Kernel\n	// Kernel.rootmodule [Minicore]\n	// Kernel.rootmodule.usermodule [Usermodule at build time]\n	// usermodule at a minimum must implement servicecallback  \n	servicecallback : function(evt, platobject)\n	{\n 		if (evt == \"systemstart\")\n		{\n			// load the platform module first \n			// Do not use loadModuleInModtask. we dont want to override the Log, Sleep, etc. :)\n			\n			if (typeof(platobject) == \"object\" && typeof(platobject[\"overridehostingmodule\"]) == \"string\")\n			{\n				modtask.platform = Kernel.loadModule(modtask, platobject[\"overridehostingmodule\"]); \n				modtask.platform[\"platobject\"] = platobject[\"platobject\"];\n			}\n			else \n			{\n				modtask.platform = Kernel.loadModule(modtask, \"host\\\\nodejs\\\\base\"); \n				modtask.platform[\"platobject\"] = platobject;\n			}				\n\n			// redirect these to the platform counterparts \n			Kernel.Log = modtask.platform.Log;\n			Kernel.Sleep = modtask.platform.Sleep;\n			Kernel.exceptionToString = modtask.platform.exceptionToString;\n			Kernel.getPlatformModule = function() { return modtask.platform; };\n			Kernel.getBuildInfo = function() { return \"2016-08-29 14:40:29\"; } ;\n			Kernel[\"getModulePath\"] =  function(name)\n			{\n				if (typeof(modtask.platform.modspath[name]) != \"string\")\n					Kernel.Fail(\"getModulePath \" + name);\n				return modtask.platform.modspath[name];\n			};\n\n			Kernel[\"getRootPathIfAny\"] = function() \n			{\n				var ret = \"\";\n				try { \n					if (typeof(Kernel.rootModule.usermodule[\"getRootPathIfAny\"]) == \"function\")\n						ret = Kernel.rootModule.usermodule[\"getRootPathIfAny\"]();\n				} catch(e) { }\n				return ret;\n			}\n			// Fix these \n			modtask.Log = Kernel.Log;\n			modtask.Sleep = Kernel.Sleep;\n			modtask.exceptionToString = Kernel.exceptionToString;\n			modtask.getPlatformModule = Kernel.getPlatformModule;\n			Kernel[\"systemhealthymsg\"] = \"System Healthy. 100 percent pass rate for modules\";\n \n			try \n			{\n				modtask.usermodule = Kernel.loadModuleInModtask(modtask, \"codegen/console/root\");\n				modtask.usermodule.servicecallback(\"init\"); \n			}\n			catch(e)\n			{\n 				var txt = \"CRASH in usermodule: \" + Kernel.exceptionToString(e);\n 				modtask.platform.showUnhandledKernelExceptionMsg(txt);\n				return txt;\n			} \n		}\n		return evt;\n	},\n\n	externalCall : function(obj, failed)\n	{\n		var msg = \"\";\n		try \n		{\n			if (failed)\n			{\n				msg = obj[\"p\"];\n			}\n			else\n			{\n				return obj[\"fn\"](obj[\"p\"]);\n			}\n 		}\n		catch(e)\n		{\n			failed = true;\n			msg = Kernel.exceptionToString(e);\n		}  \n		var ctx = \"\";\n		if (obj[\"context\"])\n			ctx = obj[\"context\"];\n		var txt = \"externalCall \" + ctx + \" :::\" + msg + \"\";\n		modtask.platform.showUnhandledKernelExceptionMsg(txt);\n		return txt;		\n	},		\n\n	getDependencies : function(moduleconfig)\n	{\n		var ret =  []; \n		return ret;		\n	}\n}\n"; 
INLINESTORE["host\\nodejs\\base"] = "\r\nvar modtask =\r\n{\r\n	platobject : false,\r\n\r\n	modspath : \r\n	{\r\n		\"file\" : \"host\\\\nodejs\\\\file\",\r\n		\"proc\" : \"host\\\\nodejs\\\\proc\",\r\n		\"http\" : \"host\\\\nodejs\\\\http\",\r\n		\"pinger\" : \"host/nodejs/pinger\",\r\n		\"osdependentfilecommon\" : \"host/nodejs/filecommon\"\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = [];\r\n		return ret;\r\n	},\r\n\r\n	getModulePath : function(name)\r\n	{\r\n		if (typeof(modtask.modspath[name]) != \"string\")\r\n			Kernel.Fail(\"getModulePath \" + name);\r\n		return modtask.modspath[name];\r\n	},\r\n\r\n	endRuntime : function()\r\n	{\r\n		Kernel.Fail(\"endRuntime for nodejs\");\r\n	},		\r\n\r\n 	showUnhandledKernelExceptionMsg : function(str)\r\n	{\r\n		try { console.log(str);} catch(e) { console.log(\"host.nodejs.showUnhandledKernelExceptionMsg.Failed\"); }\r\n	},		\r\n	\r\n	\"Log\" : function(s) \r\n	{\r\n 		try { console.log(s); } catch(e) { console.log(\"host.nodejs.Log.Failed\"); }\r\n	},\r\n\r\n	\"Sleep\" : function(miliseconds) \r\n	{\r\n	      try \r\n	      {  \r\n		 var sleep = require('sleep');\r\n		 sleep.usleep(miliseconds*1000);\r\n	      }\r\n	      catch(e)\r\n	      {\r\n		 console.log(\"host.nodejs: \" + modtask.exceptionToString(e));\r\n	      }      \r\n	},\r\n\r\n	\"exceptionToString\" : function(e) \r\n	{ \r\n		var ret  = \"\";\r\n		if (typeof(e[\"message\"]) == \"string\")\r\n		{ 	 \r\n			ret = e.message;	\r\n		}\r\n		else  \r\n		{\r\n			ret = JSON.stringify(e);\r\n		}\r\n		return ret;   	\r\n	}\r\n}\r\n\r\n"; 
INLINESTORE["codegen/console/root"] = "\r\nvar modtask = {}\r\nmodtask.mod_s_root = false;\r\nmodtask.servicecallback = function(evt)\r\n{\r\n	return evt;\r\n};\r\n\r\n// getRootPathIfAny will tell the system where ljs.js is located at (ITS a bad naming -- it is a Full File Path)\r\n// modtask/minicore will set Kernel.getRootPathIfAny to this\r\n// kernel/extstores/file will use Kernel.getRootPathIfAny to calculate getAnchorDirectory (appends ./modtask to it)\r\nmodtask.getRootPathIfAny = function() { \r\n	var ret = '';\r\n	if (modtask.mod_s_root) {\r\n		ret = modtask.mod_s_root.getRootPathIfAny();\r\n	}\r\n	return ret;\r\n}\r\n\r\nmodtask.onCommandLine = function(paramstr)\r\n{\r\n	try {\r\n		modtask.setupSystem();\r\n	}	catch(e)	{\r\n		modtask.Log(\"\\nWARNING: Cannot enable file chain: \" + modtask.exceptionToString(e) + \"\\n\");\r\n	}\r\n	modtask.mod_s_root = modtask.ldmod(\"s_root\");\r\n	modtask.mod_s_root.onCommandLine(paramstr);\r\n};\r\n\r\nmodtask.setupSystem = function()\r\n{\r\n	if (Minicore.loadObjectOverwrite)\r\n	{\r\n		modtask.Log(\"Selectors Already Setup\");\r\n	} \r\n	else \r\n	{\r\n		// do it twice to force reload from the file system (if present)\r\n		modtask.setupSelectors();\r\n		modtask.setupSelectors();\r\n	}\r\n\r\n}\r\n\r\nmodtask.setupSelectors = function()\r\n{\r\n	var modsel = modtask.ldmod(\"kernel\\\\selectors\"); \r\n	modsel.redirectStorage();\r\n	modsel.addStoreChain(\"kernel\\\\extstores\\\\file\", true);  \r\n} \r\n\r\n\r\nmodtask.getDependencies = function(moduleconfig)\r\n{\r\n	var ret = \r\n	[\r\n		[\"modtask\", \"s_root\"],\r\n		[\"modtask\", \"kernel\\\\selectors\"],\r\n		[\"modtask\", \"kernel\\\\extstores\\\\file\"],\r\n\r\n		// \r\n		[\"modtask\", \"host\\\\nodejs\\\\file\"],\r\n		[\"modtask\", \"host\\\\nodejs\\\\filecommon\"],\r\n      [\"modtask\", \"os\\\\windows\\\\file\"]\r\n	];\r\n	return ret;\r\n}\r\n"; 
INLINESTORE["s_root"] = "\r\n\r\nvar modtask = \r\n{\r\n	_verifyEmbeddedShellENDTOKENSHELLFIX : \"verifyEmbeddedShellENDTOKENSHELLFIX187a72201\",\r\n\r\n	launchparams : {},\r\n	startenv :\r\n	{ \r\n		\"ref\" : false,\r\n		\"verb\" : false,\r\n		\"vp\" : [] \r\n	},		  \r\n\r\n 	slash : \"__SLSH__\",\r\n	dot : \".\",\r\n	comma : \",\",\r\n	ref : \"root\",\r\n	maxnumberofparams : 10, \r\n	\r\n \r\n\r\n	onCommandLine : function(paramstr)\r\n	{\r\n		modtask.ldmod(\"encodedecode\\\\percent\").dec(modtask.slash, \"=\", paramstr, modtask.launchparams);  \r\n		modtask.initSession();\r\n		modtask.startSession();\r\n 	},  \r\n\r\n	initSession : function()	\r\n	{\r\n		var i;\r\n		var p0 = modtask.launchparams[\"param0\"];\r\n		for(i=1; i <= modtask.maxnumberofparams; ++i)		\r\n		{\r\n			if (typeof(modtask.launchparams[\"param\"+i]) != \"string\")\r\n				modtask.launchparams[\"param\"+i] = \"\";\r\n		}\r\n		\r\n		if (p0 == \"default\" || p0.match(/_/) || p0 == \"root\")\r\n		{\r\n			if (p0 == \"default\")\r\n			{\r\n				p0  = globalState.get(\"defaultconsoleref\");\r\n				if (p0  == \"DISABLED\")\r\n					throw { \"message\" : \"initSession.cmdline: default context was launch but defaultconsoleref is not set yet\" };\r\n			}\r\n			modtask.startenv.ref = p0;\r\n			modtask.startenv.verb = modtask.cleanupParam(modtask.launchparams[\"param1\"]);\r\n			for(i=2; i <= modtask.maxnumberofparams; ++i)\r\n			{\r\n				modtask.startenv.vp[i-2]=modtask.launchparams[\"param\"+i];\r\n				if (typeof(modtask.startenv.vp[i-2]) == \"undefined\")\r\n					modtask.startenv.vp[i-2] = \"\"; \r\n				modtask.startenv.vp[i-2] = modtask.cleanupParam(modtask.startenv.vp[i-2]); \r\n			}				\r\n\r\n		}\r\n		else \r\n		{\r\n			// root command \r\n			modtask.startenv.ref = \"root\";\r\n			modtask.startenv.verb = modtask.cleanupParam(p0);\r\n			if (p0 == \"\" || p0 == false)\r\n				modtask.startenv.verb = \"help\";\r\n\r\n 			for(i=1; i <= modtask.maxnumberofparams; ++i)\r\n				modtask.startenv.vp[i-1]=modtask.cleanupParam(modtask.launchparams[\"param\"+i]);\r\n		}\r\n		return true;		\r\n	},\r\n\r\n	cleanupParam : function(p)\r\n	{\r\n		if (typeof(p) != \"string\") return p;\r\n 		return p.replace(modtask._verifyEmbeddedShellENDTOKENSHELLFIX, \"\");\r\n	},		\r\n\r\n	startSession : function()\r\n	{\r\n		var ret ;	\r\n 		if (modtask.startenv.verb == \"\")\r\n		{\r\n			globalState.set(\"defaultconsoleref\", modtask.startenv.ref);\r\n			ret = \"\";\r\n		}\r\n		else \r\n		{\r\n			for(i=0; i < modtask.maxnumberofparams-1; ++i)\r\n			{\r\n				if (modtask.startenv.vp[i].length == 0)\r\n					modtask.startenv.vp[i] = false;\r\n			}\r\n			if (modtask.startenv.ref == \"root\")\r\n			{\r\n				ret = modtask.verbproxy(\r\n						modtask.startenv.verb,\r\n						modtask.startenv.vp[0],\r\n						modtask.startenv.vp[1],\r\n						modtask.startenv.vp[2],\r\n						modtask.startenv.vp[3],\r\n						modtask.startenv.vp[4],\r\n						modtask.startenv.vp[5]\r\n				);\r\n 			}\r\n			else \r\n			{\r\n				if (typeof(Kernel[\"callVerbOnRef\"]) == \"function\")\r\n				{\r\n					// Old system \r\n					ret = Kernel.callVerbOnRef(\r\n						modtask.startenv.ref,			\r\n						modtask.startenv.verb,\r\n						modtask.startenv.vp[0],\r\n						modtask.startenv.vp[1],\r\n						modtask.startenv.vp[2],\r\n						modtask.startenv.vp[3],\r\n						true\r\n					);\r\n\r\n					if (ret)\r\n						StdInOut.write(ret);\r\n				}\r\n				else \r\n				{\r\n					ret = \"\";\r\n					modtask.Log(\"would \" + modtask.startenv.ref + \" \" + modtask.startenv.verb + \" \" + modtask.startenv.vp[0]);\r\n				}				\r\n			}				\r\n		}\r\n	},	\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"miniroot\"],\r\n			[\"modtask\", \"encodedecode\\\\percent\"],\r\n			[\"modtask\", \"kernel\\\\selectors\"],\r\n		        [\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"encodedecode\\\\hex\"]\r\n		];\r\n		return ret;\r\n	},\r\n\r\n	getRootPathIfAny : function()\r\n	{\r\n 		if (typeof(modtask.launchparams[\"scriptpath\"]) == \"string\")\r\n			return modtask.launchparams[\"scriptpath\"];\r\n		else \r\n			return \"\";\r\n	},	\r\n\r\n	servicecallback : function(evt)\r\n	{\r\n		return evt;\r\n	},	\r\n\r\n	help  : \r\n	{\r\n		\"hview <str> [encode] : dumps a hex string\" : true,\r\n		\"eval 1 2 3 4 ...\" : true,\r\n		\"mtest [module]\": true,\r\n		\"mship [module]\": true,\r\n		\"runmodule <module> <fn> __modtask [p1] [p2]\" : true,\r\n		\"runmodule2 <module> <fn> [p1] [p2]\" : true,		\r\n		\"mview sysview\" : true,\r\n		\"help [filter]\" : true,\r\n		\"\": \"\"						\r\n	},\r\n	\r\n	contextextension : function(verb, p2, p3, p4)\r\n	{\r\n		var ext = {};\r\n		if (verb == \"xxx\")\r\n		{\r\n			ext = {\r\n			};\r\n		}\r\n		return ext;\r\n        },\r\n\r\n	urlprovider : function(page)\r\n	{\r\n		return url;\r\n	},\r\n\r\n	beforeThreadStart : function()\r\n	{\r\n		modtask.ref = globalState.get(\"defaultconsoleref\");\r\n		return true;\r\n	},\r\n\r\n	dynamicverbinit : function(verb)\r\n	{\r\n//		modtask.populateHelp();\r\n	},\r\n\r\n	parseModuleName : function(p)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");		\r\n\r\n		var myinfo = {};\r\n		myinfo[\"name\"] = p; \r\n		myinfo[\"prefix\"] = false;\r\n		var prefixes = [\"g_\", \"app_\"];\r\n		for(i=0; i < prefixes.length; ++i)\r\n		{					\r\n			if (modstr.startsWith(myinfo[\"name\"], prefixes[i]))\r\n			{\r\n				myinfo[\"prefix\"] = prefixes[i];\r\n				myinfo[\"suffix\"] = myinfo[\"name\"].replace(prefixes[i], \"\");\r\n			}\r\n		}\r\n		return myinfo;\r\n	},		\r\n\r\n	populateHelp : function(filter)\r\n	{\r\n		if (!filter)\r\n			filter = \"\";\r\n		var modstr = modtask.ldmod(\"core\\\\string\");				\r\n		modtask.Log(\"Populating help ... [\" + filter + \"]\");	\r\n  		var ctx = \r\n		{\r\n			\"fn\" : function(id, dt, p)\r\n			{\r\n				if (filter.length > 0 && !modstr.contains(p, filter))\r\n					return;\r\n				var task, p1, p2, myinfo = {}; \r\n				myinfo = modtask.parseModuleName(p);\r\n				if (myinfo[\"prefix\"])\r\n				{\r\n 					//////////////////////////////////////////////////////////\r\n					// USER MODE : If failed, we dont want to screw up root \r\n					//////////////////////////////////////////////////////////\r\n					try \r\n					{				\r\n						task = modtask.ldmod(myinfo[\"name\"]);\r\n					}\r\n					catch(e)\r\n					{\r\n						this.prnt[\"help\"][\"LOADERROR FOR: \" + myinfo[\"name\"] + \": \" + Kernel.exceptionToString(e)] = true;\r\n						return ;\r\n					}\r\n\r\n					for(p1 in task[\"cmdlineverbs\"])\r\n					{\r\n						this.prnt.cmdlineverbs[myinfo[\"suffix\"] + modtask.dot + p1] = \"proxy\"; // We will call task[\"cmdlineverbs\"][p1] through verb proxy later\r\n					}\r\n					this.prnt = modtask.extractHelpInfo(task, myinfo, this.prnt);\r\n				}\r\n			},\r\n\r\n			prnt : {}\r\n		}\r\n		ctx.prnt = this;\r\n		var selectors= modtask.ldmod(\"kernel\\\\selectors\");\r\n		selectors.iterateModules(ctx);\r\n		return 	this.cmdlineverbs;\r\n	},\r\n\r\n	extractHelpInfo : function(task, myinfo, extractedInfo, verb)\r\n	{\r\n		if (task[\"help\"])\r\n		{\r\n			if (!extractedInfo[\"help\"])\r\n				extractedInfo[\"help\"] = {};\r\n\r\n			extractedInfo[\"help\"][\"---- \" + myinfo[\"suffix\"] + \" ------\"] = true;\r\n			for(p2 in task[\"help\"])\r\n			{\r\n				var hybridname = myinfo[\"suffix\"]  + modtask.dot + p2;							\r\n				if (task[\"help\"][p2] == \"ship\")\r\n				{\r\n					extractedInfo[\"help\"][\" setup.mod2ship \" + myinfo[\"name\"]  + \" \" + p2] = true; \r\n				}\r\n				else \r\n				{\r\n					if (task[\"help\"][p2] == \"guessP2\")\r\n					{\r\n						extractedInfo[\"help\"][\" \" + hybridname + \" *GP2*\"] = true; \r\n						if (hybridname == verb)\r\n							extractedInfo[\"guessP2\"] = true;\r\n						else \r\n							extractedInfo[\"guessP2\"] = false;\r\n					}\r\n					else \r\n					{\r\n						extractedInfo[\"help\"][\" \" + hybridname] = true; 	\r\n					}	\r\n				}\r\n			}\r\n		}\r\n		return extractedInfo;\r\n	},	\r\n\r\n	verbproxy : function(verb, p2, p3, p4, p5, p6, p7, p8, p9, p10)\r\n	{\r\n		var functiontocall = false;\r\n		var needtoguess = false;\r\n		if (verb.indexOf(modtask.dot) > 0)\r\n		{\r\n			var cmd = verb.split(modtask.dot);\r\n			var modulename = \"g_\" + cmd[0];\r\n			var task1 = modtask.ldmod(modulename);\r\n			task1[\"Success\"] = function(x) { modtask.Log(x); } ;\r\n			functiontocall = task1[\"cmdlineverbs\"][cmd[1]]; \r\n			if (p2 == \"\")\r\n			{\r\n				needtoguess = modtask.extractHelpInfo(task1, \r\n						modtask.parseModuleName(modulename), {}, \r\n						verb)[\"guessP2\"];\r\n			}\r\n 		}\r\n		else \r\n		{\r\n			functiontocall = modtask.cmdlineverbs[verb];  \r\n		} \r\n\r\n		if (typeof(functiontocall) != \"function\")\r\n		{\r\n			modtask.Log(\"Uknown verb: '\" + verb + \"'. Did you mistype?\");\r\n			return ;\r\n		}\r\n\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n\r\n		if (p2 && modstr.startsWith(p2, \"__\"))\r\n		{\r\n			p2 = modtask.convertShortRefToRef(p2);\r\n		}\r\n		else if (p2 == \"\" && needtoguess)\r\n		{\r\n			modtask.Log(\"Guessing ...\");\r\n			if (typeof(globalState) == \"object\")\r\n			{\r\n				p2 = globalState.get(\"defaultconsoleref\"); \r\n			}\r\n			else \r\n				modtask.Fail(\"I cannot guess because globalState object not accessable\");\r\n		} \r\n		return functiontocall(p2, p3, p4, p5, p6, p7, p8, p9, p10);\r\n 	},\r\n\r\n	\"convertShortRefToRef\" : function(ref)\r\n	{\r\n		if (ref == \"__testshortconvert\")\r\n			return \"guessed__testshortconvert\"; \r\n\r\n		if (typeof(Kernel[\"getDepManager\"]) == \"function\")\r\n		{\r\n			var depman = Kernel.getDepManager();\r\n			return depman.convertShortRefToRef(ref);\r\n		}\r\n		else \r\n			return ref;\r\n	}, \r\n\r\n	ref : \"\",\r\n\r\n\r\ncmdlineverbs : {\r\n\r\n\r\n	\"hview\" : function(p2, rev)\r\n	{\r\n		var modhex = modtask.ldmod(\"encodedecode\\\\hex\");\r\n		if (rev)\r\n			modtask.Log(modhex.stringToHexString(p2));\r\n		else \r\n			modtask.Log(modhex.hexStringtoString(p2));\r\n	},\r\n\r\n	\"mview\" : function(extendedview)\r\n	{\r\n		var str=\"\";\r\n		var ctx = \r\n		{\r\n			\"fn\" : function(id, dt, p)\r\n			{\r\n				if (extendedview)\r\n					modtask.Log(p);\r\n				else \r\n					str += p + modtask.comma;  \r\n 			}\r\n		}\r\n		var selectors = modtask.ldmod(\"kernel\\\\selectors\");		\r\n		selectors.iterateModules(ctx);		\r\n		if (!extendedview)\r\n			modtask.Log(str);\r\n	},\r\n\r\n	// variable argument array \r\n 	\"eval\" : function()\r\n	{\r\n		var ret = \"\", i;\r\n		for(i=0; i < arguments.length; ++i)\r\n		{\r\n			if (arguments[i]) // Otherwise False\r\n			{\r\n				ret = ret + eval(arguments[i]);\r\n			}\r\n		}\r\n		modtask.Log(\"'\" + ret + \"'\");\r\n	},\r\n \r\n\r\n	\"generatesetuser\" : function()\r\n	{\r\n		modtask.Log(\"reallysetuser \" + globalState.get(\"defaultconsoleref\"));\r\n	},\r\n\r\n\r\n 	\"mtest\" : function(module, dooutofproc)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\"); \r\n		var negmod = false;\r\n		if (typeof(module) == \"string\" && module.indexOf(\"-\") == 0)\r\n		{\r\n			negmod = true;\r\n			module = module.substr(1, module.length-1);\r\n		}\r\n		if (!module || negmod)\r\n		{\r\n			modtask.Log(\"Please specify a module to test at commandline\"); \r\n			modtask.Log(Kernel[\"systemhealthymsg\"]);\r\n			return;\r\n		}\r\n		modtask.Log(\"Testing \" + module); \r\n 		mod = modtask.ldmod(module);\r\n		if (typeof(mod.UNITTEST) != \"function\")\r\n		{\r\n			modtask.Log(\"WARNING: task does not expose UNITTEST\");\r\n		}\r\n		else \r\n		{\r\n			if (typeof(dooutofproc) == \"string\") {\r\n				modtask.Log(\"OUTOFPROCTEST\");\r\n				modtask.UNITTEST(module);\r\n			}\r\n			else {\r\n				if (typeof(mod[\"verbose\"]) == \"boolean\")\r\n					mod[\"verbose\"] = true;\r\n\r\n				mod.UNITTEST();\r\n			}\r\n		}\r\n	},	\r\n\r\n	\"runmodule2\" : function(module, fn, p1, p2) \r\n	{\r\n		return modtask.cmdlineverbs.runmodule(module, fn, p1, p2,true);\r\n	},\r\n\r\n	\"runmodule\" : function(module, fn, p1, p2, dontpassinmodtask)\r\n	{\r\n		return modtask.ldmod(\"miniroot\").runmodule(module, fn, p1, p2, dontpassinmodtask); \r\n	},	\r\n\r\n	\"mship\" : function(module)\r\n	{\r\n 		var mod = modtask.ldmod(module);\r\n		if (typeof(mod.SHIP) != \"function\")\r\n		{\r\n			modtask.Log(\"WARNING: task does not expose SHIP\");\r\n		}\r\n		else \r\n		{\r\n			mod.SHIP();\r\n			modtask.Log(\"SHIP SUCCESSFUL\");\r\n		}\r\n	},\r\n\r\n	\"help\" : function(filter)\r\n	{\r\n		modtask.populateHelp(filter);\r\n 		var p;\r\n 		for(p in modtask.help)\r\n			modtask.Log(\"    \"+ p);\r\n 	},\r\n\r\n	\"sysview\" : function()\r\n	{ \r\n		var info = \r\n		{\r\n			\"Build Info\" : Kernel.getBuildInfo(),\r\n			\"AnchorPath\" : Kernel.getRootPathIfAny()\r\n		}\r\n		info['chains'] = '';\r\n		var details = {};\r\n		modtask.ldmod('kernel\\\\selectors').objectExist('___these_are_the_search_paths_for_modules___', details, false);\r\n		var chainnames = details.chainstr;\r\n		var i;\r\n		for(i=0; i < chainnames.length; ++i) {\r\n			info['chains']  += ' ' + chainnames[i];\r\n		}\r\n		var filechain = 'kernel\\\\extstores\\\\file';\r\n		if (details[filechain]) { \r\n			info['Module Resolution Paths'] = details[filechain].chainstr.replace(/___these_are_the_search_paths_for_modules___.js/g, '');\r\n		} else {\r\n			info['Module Resolution Paths'] = 'N/A';\r\n		}\r\n\r\n		var p;\r\n		for(p in info)\r\n			modtask.Log(\"\\r\\n\" + p + \": \" + info[p]);\r\n\r\n\r\n\r\n	}\r\n},	\r\n\r\nbrowserverbs : {\r\n	\"browseredverbcview\" : [\"browseredverbcview\"]	       \r\n	       \r\n},\r\ntaskpages : {}\r\n};\r\n\r\n\r\n"; 
INLINESTORE["miniroot"] = "\r\nvar modtask = \r\n{ \r\n	\"runmodule\" : function(module, fn, p1, p2, dontpassinmodtask)\r\n	{\r\n		if (typeof(module) == \"string\")\r\n		{\r\n	 		mod = modtask.ldmod(module);\r\n			if (typeof(mod[fn]) != \"function\")\r\n				modtask.Fail(\"Module \" + module + \" does not have \" + fn);\r\n			else \r\n			{\r\n				if (dontpassinmodtask == true)\r\n					return mod[fn](p1, p2);\r\n				else \r\n					return mod[fn](modtask, p1, p2);\r\n			}\r\n		}\r\n		else \r\n		{\r\n	 		mod = modtask.ldmod(module[\"module\"]);\r\n			if (typeof(mod[module[\"fn\"]]) != \"function\")\r\n				modtask.Fail(\"Module \" + module[\"module\"] + \" does not have \" + module[\"fn\"]);\r\n			else \r\n			{\r\n				if (dontpassinmodtask == true)\r\n					return mod[module[\"fn\"]](module[\"p1\"], module[\"p2\"]);\r\n				else \r\n					return mod[module[\"fn\"]](modtask, module[\"p1\"], module[\"p2\"]);\r\n			}\r\n				\r\n	 			\r\n		}\r\n	}\r\n}\r\n"; 
INLINESTORE["encodedecode\\percent"] = "\r\nvar modtask = \r\n{\r\n	fullec : false,   \r\n	ec : function(tok1, tok2, nvObj, testmode, donotescape)\r\n	{\r\n		var temp = \"\";\r\n		var p;\r\n\r\n		if (typeof(nvObj) != 'object')\r\n			return nvObj;\r\n\r\n		for (p in nvObj) \r\n		{\r\n			var str = nvObj[p] + \"\";\r\n			if (!str.match(/^function/) && p.length > 0)\r\n			{		\r\n				if (temp.length > 0)\r\n					temp+=tok1;\r\n\r\n				if (donotescape)\r\n					temp += p + tok2 + modtask.ec(tok1,tok2,nvObj[p], testmode, donotescape);\r\n				else \r\n					temp += modtask.URLEncode(p) + tok2 + modtask.URLEncode(modtask.ec(tok1,tok2,nvObj[p], testmode, donotescape));\r\n			}\r\n		}\r\n		return temp;\r\n	},\r\n\r\n	URLEncode : function(str)\r\n	{\r\n		var ret = encodeURI(str);\r\n		if (modtask.fullec) ret = ret.replace(/:/g, \"%3a\").replace(/-/g, \"%2d\");\r\n		return ret; \r\n	},\r\n\r\n	URLDecode : function(str)\r\n	{\r\n		var ret = decodeURI(str);\r\n      if (!modtask.fullec)\r\n         return ret;\r\n\r\n      var map = {\r\n         \"%24\" : \"$\",\r\n         \"%26\" : \"&\",                  \r\n         \"%2[bB]\" : \"+\",\r\n         \"%2[cC]\" : \",\",         \r\n         \"%2[fF]\" : \"/\",\r\n         \"%3[aA]\" : \":\",\r\n         \"%3[bB]\" : \";\",                \r\n         \"%3[dD]\" : \"=\",       \r\n         \"%3[fF]\" : \"?\", \r\n         \"%40\" : \"@\" \r\n      }; \r\n      var p;\r\n      for(p in map)\r\n      {\r\n         var re = new RegExp(p, 'g');  \r\n         ret = ret.replace(re, map[p]); \r\n      }\r\n		return ret;\r\n	}, \r\n\r\n	dec : function(tok1, tok2, cfg, nvObj, dontunescape)\r\n	{\r\n		var vars = cfg.split(tok1);\r\n		if (vars.length < 2)\r\n		{\r\n			if (vars.length == 1 && ((cfg+\"\").indexOf(tok2) != -1))\r\n			{\r\n 			}\r\n			else \r\n			{\r\n				return ;\r\n			}\r\n		}\r\n		for (var i=0;i<vars.length;i++) \r\n		{\r\n         if (vars[i].length == 0)\r\n            continue; \r\n			var pair = vars[i].split(tok2); \r\n         if (dontunescape)\r\n			{\r\n				nvObj[pair[0]] = pair[1];		\r\n			}\r\n			else \r\n			{\r\n				nvObj[modtask.URLDecode(pair[0])] = modtask.URLDecode(pair[1]);\r\n			}\r\n		}\r\n	}   \r\n}\r\n"; 
INLINESTORE["kernel\\selectors"] = "\r\nvar modtask = \r\n{\r\n	file : false,\r\n        modstr : false,\r\n	storemods : {},\r\n	modsql : false,\r\n\r\n	iterateModules : function(context) {\r\n		modtask.iterateStoreChain(\r\n		{\r\n			\"fn\" : function(a,b, mod)\r\n			{\r\n				mod.iterateModules(context); \r\n			}\r\n		}\r\n		);\r\n	},\r\n\r\n	objectExist : function(objectname, details, loadtoo) {\r\n 		if (typeof(details) != \"object\")\r\n			details = {}; 		\r\n		details[\"chainstr\"] = [];\r\n		var exists = false;\r\n		modtask.iterateStoreChain({\r\n			\"fn\" : function(a,b, mod) {\r\n				details[\"chainstr\"][details[\"chainstr\"].length] = b;\r\n				if (mod.objectExist(objectname, details, loadtoo)) {\r\n					exists = true;\r\n					return \"break\";\r\n				} \r\n			}\r\n		});\r\n  		details[\"found\"] = exists;\r\n        modtask.objectExistsHook(objectname, details);\r\n		return exists;\r\n	},\r\n\r\n   objectExistsHook : function() { },\r\n\r\n	redirectStorage : function() {\r\n		if (Minicore.loadObjectOverwrite == false)\r\n			Minicore.loadObjectOverwrite = modtask.loadObject2;\r\n		else\r\n		{	\r\n			// It should only be set to me :)\r\n			if (Minicore.loadObjectOverwrite != modtask.loadObject2)\r\n				modtask.Fail(\"redirectStorage called after already been set\");		\r\n		}\r\n	},\r\n\r\n	loadObject2 : function(_modtask, objecttype, objectname, inithash, donotcallinit, funcs) {\r\n 		var ret ; \r\n\r\n		// I am a singleton -- :-)\r\n		if (objectname == modtask.__myname)\r\n			return modtask; \r\n\r\n		if (typeof(funcs) != \"object\" || typeof(funcs[\"existfunc\"]) != \"function\" || typeof(funcs[\"parsefunc\"]) != \"function\")\r\n		{\r\n			var details = {};\r\n			if (modtask.objectExist(objectname, details, true))\r\n			{\r\n				ret = Minicore.rawLoadObject(_modtask, objecttype, objectname, function() { return details[\"obj\"]; }); 				\r\n			}\r\n			else 		\r\n				_modtask.Fail(Minicore.EncodeDecode_encodeErrorMessage(\"loadObject2\", Minicore.ERR_DOESNOT_EXIST, objectname));\r\n		}\r\n		else \r\n		{\r\n			ret =  Minicore.loadObject2(_modtask, objecttype, objectname, inithash, donotcallinit, funcs);\r\n\r\n		}\r\n		return ret;\r\n	},\r\n\r\n	getUnparsedObj : function(objref) {\r\n		var details = { \"unparsed\" : true };\r\n		if (modtask.objectExist(objref, details, true))\r\n			return details[\"obj\"];\r\n		else \r\n			modtask.Fail(\"getUnparsedObj. not exists \" + objref);\r\n 	},\r\n\r\n	augmentConfig : function(_modtask, failifnot, failforinfo) {\r\n		var details = {};\r\n		details[\"failifnot\"] = failifnot;\r\n		details[\"failforinfo\"] = failforinfo;\r\n		return modtask.configExists(_modtask, details, true);\r\n	},\r\n\r\n	configExists : function(_modtask, details, loadtoo) {\r\n		if (typeof(_modtask[\"configname\"]) != \"string\")\r\n		{\r\n			modtask.Fail(\"you must define 'configname' for \" + _modtask.__myname + \", since it tries to augmentConfig\");\r\n		}\r\n  		details[\"found\"] = false;\r\n		details[\"pathstrs\"] = \"\";\r\n		details[\"__modparent\"] = _modtask.__myname;\r\n		var paths = [\"..\\\\thirdparty\\\\config\\\\\" + _modtask.configname, \"config\\\\\" + _modtask.configname];\r\n		for(i=0; i < paths.length; ++i)\r\n		{\r\n			details[\"pathstrs\"] += \", \" + paths[i];\r\n	 		if (modtask.objectExist(paths[i], details, loadtoo))\r\n			{\r\n				details[\"found\"] = paths[i];\r\n				if (loadtoo)\r\n				{\r\n					details[\"obj\"][\"__modparent\"] = _modtask;	\r\n					modtask.augmentModule(_modtask, details[\"obj\"]);\r\n				}\r\n				break;\r\n			}\r\n		}\r\n 		if ((details[\"failifnot\"] && details[\"found\"] == false) || details[\"failforinfo\"])\r\n		{\r\n 			modtask.Fail(\"augmentConfig.formatLoadInfo: \" + modtask.formatLoadInfo(details));\r\n		}\r\n		return modtask;\r\n	},\r\n\r\n	getPathToCurrentConfigModule : function(_modtask) {\r\n		var details = {};\r\n		modtask.configExists(_modtask, details, false);\r\n		if (details[\"found\"])\r\n			return details[\"found\"];\r\n		else \r\n			modtask.Fail(\"getPathToCurrentConfigModule \" + _modtask.__myname);\r\n 	},\r\n\r\n	formatLoadInfo : function(details, breakdownformat) {\r\n		var info = Minicore.newLine, p, i, chainstore;\r\n		var chaininfo = \"\", foundinfo = \"\";\r\n\r\n		foundinfo = (details[\"found\"] ? \"module found\" : \"module is missing\" ) + Minicore.newLine;\r\n		info += \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" + Minicore.newLine;\r\n		info += foundinfo;\r\n		info += \"__modparent: \" + details[\"__modparent\"] + Minicore.newLine;\r\n		info +=	\"Tried to load these modules: \" + details[\"pathstrs\"] + Minicore.newLine;\r\n		info += \"Chains where: \";\r\n		for(i=0; i < details[\"chainstr\"].length; ++i)\r\n		{\r\n			chainstore = details[\"chainstr\"][i];\r\n			chaininfo += Minicore.newLine + chainstore;\r\n			if (details[chainstore])\r\n			{\r\n				chaininfo += \" [ \";\r\n				for(p in details[chainstore])\r\n					chaininfo += details[chainstore][p] + \" \";\r\n				chaininfo += \" ] \";\r\n			}\r\n		}		\r\n		chaininfo += Minicore.newLine;\r\n		info += chaininfo;\r\n		if (details[\"found\"])\r\n		{\r\n			// placeholder \r\n			info += \"storagetype: \" + details[\"storagetype\"] + Minicore.newLine; \r\n			info += \"__loadObject2Path: \" + details[\"obj\"][\"__loadObject2Path\"] + Minicore.newLine ;\r\n			info += \"OBJECTDUMP\";\r\n			for(p in details[\"obj\"])\r\n				info += Minicore.newLine + \"  \" + p + \": \" + details[\"obj\"][p];\r\n		}\r\n 		info += \"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" + Minicore.newLine;\r\n\r\n		if (breakdownformat)\r\n		{\r\n			return { \"chaininfo\" : chaininfo, \"foundinfo\" : foundinfo} ;\r\n		}\r\n		else \r\n		{\r\n			return info;\r\n		}\r\n	},\r\n\r\n	getValidator : function() {\r\n		var ret =false;\r\n		if (modtask.objectExist(\"codegen\\\\validator\"))\r\n			ret = modtask.ldmod(\"codegen\\\\validator\");\r\n		return ret;\r\n	},\r\n\r\n	augmentModule : function(obj1, obj2) {\r\n		var p;\r\n		if (!obj2)\r\n			return obj1;\r\n		for(p in obj2)\r\n		{\r\n			if (p.indexOf(\"__\") == 0)\r\n				continue;\r\n			obj1[p] = obj2[p];\r\n		}\r\n		return obj1;\r\n	},\r\n\r\n	validateConfig : function(_modtask, prop, type)\r\n	{	\r\n		if (typeof(_modtask[prop]) != type)\r\n 			modtask.Fail(\"validateConfig failed for \" + prop + \" on \" + _modtask.__myname); \r\n		return modtask;\r\n	},\r\n\r\n\r\n	init : function()\r\n	{\r\n		modtask.modstr = Kernel.loadModuleInModtask(modtask, \"core\\\\string\"); \r\n		modtask.addStoreChain(\"kernel\\\\extstores\\\\inline\");\r\n 	},			\r\n\r\n	iterateStoreChain : function(ctx)\r\n	{\r\n		var p, i=0;\r\n		var order = [\"kernel/extstores/webstorage\", \"kernel\\\\extstores\\\\file\", \"kernel\\\\extstores\\\\inline\"];\r\n		var j;\r\n		for(j=0; j < order.length; ++j)\r\n		{\r\n			p = order[j]; \r\n			if (modtask.storemods[p])\r\n			{\r\n				if (ctx[\"fn\"](i++, p, modtask.storemods[p]) == \"break\")\r\n					break;\r\n			}\r\n		}\r\n	},\r\n\r\n	reconfigStoreChain : function(chainname, failifnot, failforinfo)\r\n	{\r\n		modtask.augmentConfig(modtask.storemods[chainname], failifnot, failforinfo); 	\r\n	},\r\n\r\n	addStoreChain : function(chainname, allowredo)\r\n	{\r\n		// Avoid loops \r\n		if (typeof(modtask.storemods[chainname]) == \"object\" && !allowredo)\r\n			return modtask.storemods[chainname];\r\n		modtask.storemods[chainname] = modtask.ldmod(chainname);\r\n		modtask.reconfigStoreChain(chainname); 		\r\n		if (typeof(modtask.storemods[chainname][\"afterAdd\"]) == \"function\")\r\n			modtask.storemods[chainname][\"afterAdd\"](modtask);\r\n		modtask.storemods[chainname][\"ldmod\"] = function(x) { modtask.Fail(\"StoreChain may only loadObject/ldmod on init. Fix this for \" + chainname); } ;\r\n      return modtask.storemods[chainname];\r\n	},		\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\extstores\\\\inline\"]  \r\n		];\r\n		return ret;\r\n	}	\r\n}\r\n"; 
INLINESTORE["core\\string"] = "\r\nvar modtask = \r\n{\r\n	VERIFY_STRING2 : function(res, val)\r\n	{\r\n		return modtask.VERIFY_STRING(modtask, res, val);\r\n	},\r\n\r\n	VERIFY_STRING : function(ctx, res, val)\r\n	{		\r\n		if (res != val || typeof(res) == \"undefined\" || typeof(val) == \"undefined\")\r\n			ctx.Fail(Minicore.newLine + \"VERIFY_STRING(\" + Minicore.newLine + \"'\" + (res + \"\").replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\") + \"'\" + Minicore.newLine + \" !=  \" + Minicore.newLine +  \"'\" + val + \"')\");\r\n	},\r\n\r\n	VERIFY_SUBSTRING2 : function(res, val)\r\n	{\r\n		if (typeof(res) == \"undefined\" || typeof(val) == \"undefined\" || !modtask.contains(res, val))\r\n			modtask.Fail(\"VERIFY_SUBSTRING(\" + Minicore.newLine + \"'\" + res + \"'\" + Minicore.newLine + \" NOT_SUPERSTRING \" + Minicore.newLine +  \"'\" + val + \"')\");\r\n	},		\r\n\r\n	splitLast : function(str, token)\r\n	{\r\n		var tmp = str.split(token);\r\n		if (tmp.length <2) modtask.Fail(\"splitLast.\" + str + \".\" + token);\r\n		var ret = [];\r\n		ret[0] = \"\";\r\n		ret[1] = tmp[tmp.length-1];\r\n		ret[0] = str.substr(0, str.length-ret[1].length-token.length);\r\n		return ret;\r\n	},		\r\n	\r\n	replaceTokens : function(content, tokens)\r\n	{\r\n		var p;\r\n		for(p in tokens)\r\n		{\r\n			var exp = p.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\[/g,\"\\\\[\").replace(/\\$/g, \"\\\\$\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\");\r\n 			var re = new RegExp(exp,\"g\");\r\n			content = content.replace(re, tokens[p]);		\r\n		}\r\n		return content;\r\n	},\r\n\r\n	toByteArray : function(str)\r\n	{\r\n		var i, ret = [];\r\n		for(i=0; i < str.length; ++i)\r\n			ret[i] = str.charCodeAt(i);\r\n	       return ret;	\r\n	},\r\n		\r\n	trim : function(str, extra)\r\n	{\r\n		str = str.replace(/^\\s+|\\s+$/g, \"\");		\r\n		if (extra == \"nonprintable\")			\r\n			str = str.replace( /[^a-zA-Z0-9\\s-@\\.\\<\\>=\"'_\\\\\\&,\\/]/g, \"\"); \r\n		return str;\r\n	},\r\n\r\n	contains : function(str1, str2)\r\n	{\r\n		var i;\r\n		if (typeof(str2) == \"object\")\r\n		{\r\n			for(i=0; i < str2.length; ++i)\r\n				if (modtask.contains(str1, str2[i]))\r\n					return true; \r\n		}\r\n		str1 = str1 + \"\";str2 = str2 + \"\";\r\n		return (str1.indexOf(str2) >= 0);\r\n	},\r\n\r\n	noCapsPresent : function(str)\r\n	{\r\n		return str.match(/[A-Z]+/) == null;\r\n\r\n	},\r\n\r\n\r\n	strClean1013 : function(str, rpl, keep1013)\r\n	{\r\n		var ret = \"\";\r\n		var i;\r\n		for(i=0; i < str.length; ++i)\r\n		{\r\n			if (str.charCodeAt(i) == 13 || str.charCodeAt(i) == 10)\r\n			{\r\n				if (keep1013)\r\n					ret += str.substr(i,1);			\r\n				if (rpl)\r\n					ret += rpl\r\n				continue;\r\n			}\r\n			else \r\n				ret += str.substr(i,1);\r\n\r\n		}\r\n		return ret;\r\n	},	\r\n\r\n	startsWith : function(str1, str2)\r\n	{\r\n		var core = modtask.ldmod(\"core\\\\core\");\r\n		if (core.realTypeOf(str2) == \"array\")\r\n		{\r\n			var p;\r\n			for(p in str2)\r\n			{\r\n				if (this.startsWith(str1, str2[p]))\r\n					return true;\r\n			}\r\n			return false;\r\n		}\r\n		// placeholder \r\n		if (str1.length >= str2.length)\r\n		{\r\n			if (str1.substr(0, str2.length) == str2)\r\n				return true;\r\n		}\r\n		return false;\r\n	},		\r\n\r\n	endsWith : function(str1, str2)\r\n	{\r\n		if (str1.length >= str2.length)\r\n		{\r\n			if (str1.substr(str1.length-str2.length, str2.length) == str2)\r\n				return true;\r\n		}\r\n		return false;\r\n	},\r\n\r\n	nSpace: function(s,n)\r\n	{\r\n		return modtask.nStrrpt(s, n, \" \");\r\n	},\r\n\r\n	nStrrpt : function(s,n, str)\r\n	{\r\n		var ret = s + \"\";\r\n		while(ret.length < n)\r\n			ret += str;\r\n		return ret;\r\n	},\r\n\r\n	twoDigits : function(s)\r\n	{\r\n		if (s < 10)\r\n			return \"0\" + s;\r\n		else \r\n			return s;\r\n	},\r\n\r\n	randomNDigit : function(n)\r\n	{\r\n		var i;\r\n		var ret = \"\";\r\n		for (i=0; i < n ; ++i)\r\n			ret += (Math.round(Math.random()*1000) + \"\").substr(0,1);\r\n		return ret;\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n		var ret =  \r\n		[\r\n			[\"modtask\", \"core\\\\core\"] \r\n		]; \r\n		return ret;		\r\n	} \r\n}\r\n\r\n"; 
INLINESTORE["core\\core"] = "\r\nvar modtask = \r\n{\r\n	isUndef : function(v)\r\n	{\r\n		return (typeof(v) == \"undefined\");\r\n	},\r\n\r\n	realTypeOf : function(v) {\r\n	  if (typeof(v) == \"object\") {\r\n	    if (v === null) return \"null\";\r\n		// The constructor based approach (v.constructor == (new Array).constructor ) does not work\r\n		  // when objects are compared cross window (i.e. ide editor)\r\n		  if (Object.prototype.toString.call(v) == Object.prototype.toString.call([])) return \"array\";\r\n	    if (v.constructor == (new Date).constructor) return \"date\";\r\n	    if (v.constructor == (new RegExp).constructor) return \"regex\";\r\n	    return \"object\";\r\n	  }\r\n	  return typeof(v);\r\n	},        \r\n\r\n	arrayMatch : function(p, arr)\r\n	{\r\n		var i;\r\n		for(i=0; i < arr.length; ++i)\r\n			if (p.match(arr[i]))\r\n				return true;\r\n		return false;\r\n	},\r\n		\r\n	arrayIndexExactMatch : function(p, arr)\r\n	{\r\n		var i;\r\n		for(i=0; i < arr.length; ++i)\r\n		{\r\n			if (p == arr[i])\r\n				return i;\r\n		}\r\n		return -1;\r\n	},\r\n\r\n	verifyArgs : function()\r\n	{\r\n		modtask.Fail('deprecated/use/core/verify.verifyArgs');\r\n	},\r\n\r\n	augmentObject :function(obj1, obj2)\r\n	{\r\n		var p;\r\n		if (!obj2)\r\n			return obj1;\r\n		for(p in obj2)\r\n			obj1[p] = obj2[p];\r\n		return obj1;\r\n	},\r\n\r\n	augmentArray : function(arr1, arr2)\r\n	{\r\n		var i;\r\n		var j = arr1.length;\r\n		for(i=0; i < arr2.length;++i)\r\n			arr1[j++] = arr2[i];\r\n		return arr1;\r\n	},\r\n\r\n   cloneFunction : function(fn, max, now)\r\n   {\r\n    var that = fn;\r\n    var temp = function temporary() { return that.apply(fn, arguments); };\r\n    for( key in fn ) {\r\n        temp[key] = modtask.cloneObject(fn[key], max, now + 1);\r\n    }\r\n    return temp;\r\n   },                  \r\n\r\n	cloneObject : function(obj, max, now) \r\n   {\r\n      if (!max) max = 10;\r\n      if (!now) now = 1;\r\n      if (now > max)\r\n         modtask.Fail(\"cloneObject.cannot.go.deeper than.\" + max);\r\n\r\n      if (typeof(obj) == \"function\")\r\n         return modtask.cloneFunction(obj, max, now);       \r\n      if(obj == null || typeof(obj) != 'object')\r\n         return obj; \r\n      if (modtask.realTypeOf(obj) == \"array\")\r\n         return obj.slice(0);  \r\n      var temp = {};       \r\n      for(var key in obj)\r\n         temp[key] = modtask.cloneObject(obj[key], max, now+1);\r\n      return temp;\r\n	},\r\n\r\n   // order is important \r\n	patchObject : function(obj, patch)\r\n        {\r\n		var newobj = modtask.cloneObject(obj);\r\n		var p;\r\n		for(p in obj) if (!modtask.isUndef(patch[p])) newobj[p] = patch[p]; \r\n		return newobj;\r\n	}, 		      \r\n\r\n	arrayIndexMatch :function(p, arr, reverse)\r\n	{\r\n		var i;\r\n		p = p + \"\";\r\n		for(i=0; i < arr.length; ++i)\r\n		{\r\n			if (p.length > 0 && arr[i].length < 1)\r\n				continue;\r\n			if (reverse)\r\n			{\r\n				if (arr[i].match(p))\r\n					return i;\r\n			}\r\n			else \r\n			{\r\n				if (p.match(arr[i]))\r\n					return i;\r\n			}\r\n		}\r\n		return -1;\r\n	},\r\n\r\n	objToArr : function(obj)\r\n	{\r\n		var p, ret = [];\r\n		for(p in obj) ret[ret.length] = p;\r\n		return ret;\r\n	},		\r\n\r\n	getFirstElement : function(obj)\r\n	{\r\n		var p;\r\n		for(p in obj) { break; } ;		\r\n		return p;\r\n	},\r\n\r\n	isEmpty : function(obj)\r\n	{\r\n		var p;\r\n		for(p in obj) return false;\r\n		return true; \r\n	},\r\n\r\n	obj : function(p, v) { var ret = {}; ret[p] = v; return ret; } \r\n}\r\n"; 
INLINESTORE["kernel\\extstores\\inline"] = "\r\nvar modtask =\r\n{\r\n	configname : \"kernel\\\\extstores\\\\inline\",\r\n\r\n 	objectExist : function(objectname, details, loadtoo)\r\n	{\r\n		var exists = false;\r\n		if (!exists)\r\n		{\r\n			details[\"storagetype\"] = \"inline\"; \r\n			exists = Minicore.objectExist(\"modtask\", objectname); \r\n			if (exists && loadtoo)\r\n			{\r\n				if (details[\"unparsed\"] == true)\r\n				{\r\n					details[\"obj\"] = Minicore.getInlineJScriptForObj(objectname); \r\n				}\r\n				else \r\n				{\r\n					details[\"obj\"] = Minicore.loadObject2(modtask, \"modtask\", objectname, false, true);\r\n				}\r\n			}\r\n		}	\r\n		return exists;\r\n	},\r\n\r\n	// todo: include relative pathinformation in the second param 	\r\n	iterateModules : function(context) \r\n	{\r\n		if (typeof(INLINESTORE) == \"object\")\r\n		{\r\n			var p ;\r\n			for(p in INLINESTORE)\r\n			{\r\n				// var name = p.split(\"\\\\\");\r\n				// name = name[name.length-1];			\r\n				var name = p;\r\n				context[\"fn\"](\"\", \"\", name);\r\n			}\r\n		}\r\n	}	\r\n}\r\n"; 
INLINESTORE["encodedecode\\hex"] = "\r\nvar modtask = \r\n{\r\n	stringToHexString : function(str)\r\n	{\r\n		var ret = \"\";\r\n		var val;\r\n		for(i=0; i < str.length; ++i)\r\n		{\r\n			val = str.charCodeAt(i).toString(16) + \"\";\r\n			if (val.length < 2)\r\n				val = \"0\" + val;\r\n			ret = ret + val; \r\n		}\r\n		return ret;\r\n	},\r\n\r\n	hexStringtoString : function(str)\r\n        {\r\n 		var ret = \"\", hx;\r\n		if (str.length % 2 != 0)\r\n		{\r\n			modtask.Fail(\"hexStringtoString, Invalid Param Length: \" + str.length);\r\n			return ;\r\n		}\r\n		for(i=0; i < str.length; i+=2)\r\n		{\r\n			hx = str.substr(i,1) + str.substr(i+1,1); \r\n			if (hx.match(/[^0-9ABCDEFGabcdef]/))\r\n			{\r\n				modtask.Fail(\"hexStringtoString, Invalid character in string: \" + hx);\r\n				return ;\r\n			}\r\n			hx = parseInt(hx, 16);\r\n			ret += String.fromCharCode(hx);\r\n		}\r\n		return ret;\r\n	}	\r\n}			    \r\n"; 
INLINESTORE["kernel\\extstores\\file"] = "\r\nvar modtask =\r\n{\r\n   seperator : '/',\r\n	defaultPathsToSearch : [],\r\n	externalPathResolver : false,\r\n	pathCache : {},\r\n	file : false,\r\n	modstr : false,\r\n	getparseerrorinfo : true,\r\n	modsel : false, \r\n	modpath : false,\r\n	extentionstr : \".js\",\r\n	configname : \"kernel\\\\extstores\\\\file\",\r\n \r\n	afterAdd : function(modsel)\r\n	{\r\n		modtask.modsel = modsel;\r\n	},\r\n\r\n	objectExist : function(objectname, details, loadtoo)\r\n	{\r\n		var exists = false, decodefunc = function(str) { return str; };\r\n		if (!exists)\r\n		{\r\n			details[\"storagetype\"] = \"file\";\r\n			var pth = modtask.getObjectPath(objectname, true, details);\r\n			if (pth != false)\r\n				exists = modtask.file.FileExists(pth);\r\n			if (exists)\r\n			{\r\n            details[\"objpath\"] = pth;\r\n            if (loadtoo)\r\n            {\r\n               if (details[\"unparsed\"] == true)\r\n               {\r\n                  details[\"obj\"] = modtask.file.readFile(pth);\r\n               }\r\n               else \r\n               {\r\n                  if (modtask.modstr.contains(pth, \"needsobfuscate\"))\r\n                  {\r\n                     modtask.Fail(\"needsobfuscate not implemented\");\r\n                  }\r\n                  details[\"obj\"] = modtask.loadFromFileParseFunc(modtask, pth, \"modtask\", decodefunc);\r\n               }\r\n            }\r\n			}\r\n		} \r\n		return exists;\r\n	},\r\n\r\n	iterateModules : function(context) \r\n	{\r\n		var tmpcontext1 = {\r\n			\"fn\" : function(a, b, path) {\r\n				if (!modtask.file.folderExists(path)) {\r\n					return;\r\n				}\r\n				var tmpcontext = {\r\n					\"path\" : path,  \r\n					\"fn\" : function(a, b, taskname)\r\n					{\r\n						if ((!modtask.modstr.endsWith(taskname, \"~\")) && modtask.modstr.endsWith(taskname, modtask.extentionstr)) \r\n						{\r\n							taskname = taskname.split(\".\")[0];\r\n							context[\"fn\"](\"\", \"\", taskname);\r\n						}					\r\n					}\r\n				};\r\n				modtask.file.iterateFoldercontent(modtask, tmpcontext);	 \r\n			} \r\n		};\r\n		modtask.iteratePathsToSearch(tmpcontext1);\r\n 	},\r\n\r\n 	getObjectPath : function(byname, dontfailifnotexist, details)\r\n	{\r\n		var ret = false;		\r\n 		if (modtask.pathCache[byname])\r\n		{		\r\n		}\r\n		else \r\n		{	\r\n			var tmpcontext = {\r\n				\"fn\" : function(a, b, path)\r\n				{\r\n					ret = modtask.file.pathCombine(path, byname + modtask.extentionstr);\r\n					if (typeof(details) == \"object\")\r\n					{\r\n						if (!details[modtask.__myname])\r\n						{\r\n							details[modtask.__myname] = { \"chainstr\" : \"\" };\r\n						}\r\n						details[modtask.__myname][\"chainstr\"] += \", \" + ret;\r\n					}				       	\r\n					if (modtask.file.FileExists(ret))\r\n					{\r\n						return \"true\";\r\n					} \r\n					else \r\n					{\r\n						ret = false;\r\n					}\r\n				} \r\n			};\r\n			modtask.iteratePathsToSearch(tmpcontext); 			\r\n			if (ret == false)\r\n			{\r\n				if (dontfailifnotexist)\r\n				{\r\n					modtask.pathCache[byname] = false;\r\n				}\r\n				else \r\n				{\r\n					modtask.Fail(\"getObjectPath.object not found \" + byname);\r\n				}\r\n			}\r\n			else \r\n				modtask.pathCache[byname] = ret;\r\n		}\r\n		return modtask.pathCache[byname]; \r\n	},\r\n\r\n	iteratePathsToSearch : function(context)\r\n	{\r\n		var paths = modtask.defaultPathsToSearch;\r\n      var anchorpath = modtask.getAnchorDirectory();\r\n		if (typeof(modtask.externalPathResolver) == \"function\")\r\n		{\r\n			paths = modtask.externalPathResolver(modtask);\r\n		} \r\n 		var i, path;\r\n		for(i=0; i < paths.length; ++i) {\r\n			path = modtask.modminipath.pathMap(paths[i]);\r\n			if (!modtask.modstr.endsWith(path, modtask.seperator))\r\n				modtask.Fail(\"externalPathResolver has and entry that doesn't end in '\" + modtask.seperator + \"'. Please make sure the entry \" + i + \"(\" + path + \") in thirdparty/config/kernel/extstores/file.js ends with \" + modtask.seperator );\r\n\r\n			if (path.indexOf('rel:') == 0) {\r\n				path = path.replace(/^rel:/, '');\r\n				path = modtask.file.pathCombine(anchorpath, path);\r\n			}	\r\n			if (context[\"fn\"](\"\", \"\", path) == \"true\")\r\n				break;\r\n		}\r\n	},	\r\n\r\n	loadModuleInModtaskFromPath : function(_modtask, path, decodefunc)\r\n	{\r\n		if (typeof(decodefunc) != \"function\")\r\n			decodefunc = function(str) { return str; };	\r\n\r\n		var funcs = \r\n		{\r\n			existfunc : function(objecttype, objectname) { return modtask.file.FileExists(objectname); } ,\r\n			parsefunc : function(_modtask, objname, objecttype) { return modtask.loadFromFileParseFunc(_modtask, objname, objecttype , decodefunc); }\r\n		}\r\n		// true means do not validate\r\n		return Kernel.loadModuleInModtask(_modtask, path, true, funcs);\r\n	},\r\n\r\n	// NOTE: Things get messed up when trying to load a modtask with the conflicting properties as ourselves.\r\n	// One example is the config module for us :)\r\n	loadFromFileParseFunc : function(_modtask, objname, objecttype, decodefunc)\r\n	{\r\n		var __tempobjstore = \"\";\r\n		try\r\n		{\r\n			__tempobjstore = Minicore.nakedParseStr(_modtask, objname, objecttype, decodefunc(modtask.file.readFile(objname))); \r\n			__tempobjstore[\"__loadObject2Path\"] = objname;							\r\n		}\r\n		catch(e)\r\n		{\r\n			var err = \"loadFromFileParseFunc \" + Minicore.newLine;\r\n		        err += \"file   : \" + objname + Minicore.newLine;\r\n			err += \"error  : \" + modtask.exceptionToString(e) + Minicore.newLine;\r\n			err += \"parser : \";\r\n			if (modtask.getparseerrorinfo)\r\n			{\r\n				try \r\n				{\r\n					var validator = modtask.modsel.getValidator();\r\n					if (validator) \r\n					{\r\n						err += validator.getSyntaxErrorInfo(objname).description;\r\n					}\r\n					else \r\n					{\r\n						err += \"not available since validator not present\";\r\n\r\n					}\r\n				}\r\n				catch(e)\r\n				{\r\n					err += \"not available due to an internal exception\"\r\n				}\r\n	\r\n			}\r\n			_modtask.Fail(err);\r\n		}\r\n 		return __tempobjstore;\r\n	},	\r\n	\r\n	getAnchorDirectory : function()\r\n        {\r\n		var path = modtask.file.getPathNameFromFullPath(Kernel.getRootPathIfAny());\r\n		if (path.length == 0)\r\n			path = \".\";\r\n 		return path + modtask.seperator + \"modtask\";\r\n	},\r\n\r\n	init : function()\r\n	{\r\n		modtask.modpath = modtask.ldmod(\"path\");\r\n	   modtask.file = modtask.ldmod(\"file\");	\r\n		modtask.modstr = modtask.ldmod(\"core\\\\string\");\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator; \r\n      // [\"\\\\\", \"\\\\..\\\\thirdparty\\\\\"],     \r\n      modtask.defaultPathsToSearch = ['rel:' + modtask.seperator, 'rel:' + modtask.seperator + '..' + modtask.seperator + \"thirdparty\" + modtask.seperator];   \r\n	},\r\n \r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n         [\"modtask\", \"minipath\"],\r\n			[\"modtask\", \"file\"],\r\n			[\"modtask\", \"path\"], \r\n	      [\"modtask\", \"core\\\\string\"]	\r\n		];\r\n		return ret;\r\n	}		\r\n}\r\n"; 
INLINESTORE["minipath"] = "\nvar modtask = {};\nmodtask.seperator = \"/\";\nmodtask.pathMap = function(path)\n{\n	path = path + \"\";\n	switch(modtask.seperator)\n	{\n		case \"/\" :\n			path = path.replace(/\\\\/g, modtask.seperator);\n			break;\n		case \"\\\\\" :\n			path = path.replace(/\\//g, \"\\\\\");\n			break;\n	}				\n	return path; \n};\nmodtask.init = function()\n{\n	if (modtask.ldmod(\"kernel/plat\").getOSName() == \"windows\")\n	{\n		modtask.seperator = \"\\\\\";\n	};\n}\n\nmodtask.getDependencies = function() { return [['modtask', 'kernel/plat']]; };\n"; 
INLINESTORE["kernel/plat"] = "\nvar modtask = {};\nmodtask.getOSName = function()\n{\n	var ret = 'unix';\n	if (Minicore.rootModule.platform.__myname.indexOf('cscript') > 0)\n		ret = 'windows';\n	return ret; \n};\n"; 
INLINESTORE["file"] = "\r\nvar modtask =\r\n{\r\n	str : false,\r\n   verbose : false, 	\r\n\r\nseperator : \"/\",\r\nnewLine : \"\\r\\n\",\r\n\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\logging\"],\r\n			[\"modtask\", \"minipath\"]\r\n		];\r\n		return ret;\r\n	},\r\n\r\n	init : function()\r\n	{\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator;\r\n\r\n		\r\n		modtask.str = modtask.ldmod(\"core\\\\string\"); \r\n		var _File = modtask.ldmod(Kernel.getModulePath(\"file\"));\r\n		if (_File[\"afterInit\"])\r\n			_File[\"afterInit\"](modtask);\r\n\r\n		modtask.ldmod(\"kernel\\\\logging\").makeVerboseSensitive(modtask);\r\n \r\n		modtask.FileExists = function(path)		\r\n		{\r\n			return _File.FileExists(modtask.modminipath.pathMap(path));\r\n		};\r\n		modtask.folderExists = function(path)\r\n		{\r\n			return _File.folderExists(modtask.modminipath.pathMap(path));\r\n		};\r\n		modtask.mappedCopy = _File.mappedCopy;\r\n		modtask.iterateFilecontent = function(_modtask, context)  \r\n		{\r\n		if (!context[\"path\"])\r\n			_modtask.Fail(\"path not set\");\r\n\r\n		context[\"path\"] = modtask.modminipath.pathMap(context[\"path\"]);\r\n		 _File.iterateFilecontent(_modtask, context);\r\n		};\r\n		modtask.iterateFilecontent2 = function(context) { return modtask.iterateFilecontent(modtask, context); } ;  \r\n\r\n		modtask.iterateFoldercontent = function(_modtask, context)\r\n		{\r\n			if (!context[\"path\"])\r\n				_modtask.Fail(\"iterateFoldercontent.path not set\");\r\n			context[\"path\"] = modtask.modminipath.pathMap(context[\"path\"]);\r\n			return _File.iterateFoldercontent(_modtask, context);\r\n		}\r\n		modtask.iterateFoldercontent2 = function(context) { return modtask.iterateFoldercontent(modtask, context); } \r\n\r\n		modtask.createFolder3 = function(path) { return modtask.createFolder2(modtask, path); } ;\r\n		modtask.createFolder2 = \r\n		function(_modtask, path)\r\n		{	\r\n			path = modtask.modminipath.pathMap(path);\r\n			return _File.createFolder2(_modtask, path);\r\n		};\r\n		modtask.removeFolder = function(_modtask, destdir)\r\n		{\r\n			return _File.removeFolder(_modtask, modtask.modminipath.pathMap(destdir));\r\n		};\r\n		modtask.removeFolder2 = function(path) { return modtask.removeFolder(modtask, path); } ;\r\n\r\n		modtask.getTempFullFilePath = _File.getTempFullFilePath;\r\n		modtask.getTempFullPath = _File.getTempFullPath;		\r\n\r\n		// This is the one that adds \\r\\n at the end \r\n		modtask.writeToTextFile = function(file, str)\r\n		{\r\n			return modtask.writeFile(file, str + modtask.newLine);\r\n		}\r\n\r\n		 // This is the good one \r\n		modtask.writeFile = function(file, str)\r\n		{\r\n			return _File.writeFile(modtask.modminipath.pathMap(file), str);\r\n		}\r\n	\r\n		modtask.deleteFile = function(path) { return _File.deleteFile(modtask.modminipath.pathMap(path)); } ;\r\n		modtask.readFileEx = function(_modtask, path, absolute)\r\n		{\r\n			path = modtask.modminipath.pathMap(path);\r\n			return _File.readFileEx(_modtask, path, absolute);\r\n		};\r\n\r\n		modtask.readFile = function(path) { return modtask.readFileEx(modtask, path, true); } ;  \r\n		modtask.appendToFile = function(path, str)\r\n		{\r\n			return _File.appendToFile(modtask.modminipath.pathMap(path), str);\r\n		}\r\n		modtask.MoveFile = function(_modtask, src, dst)\r\n		{\r\n			return _File.MoveFile(_modtask, modtask.modminipath.pathMap(src), modtask.modminipath.pathMap(dst));\r\n		}\r\n		modtask.MoveFile2 = function(src, dest) { return _File.MoveFile(modtask, src, dest); };\r\n\r\n		modtask.fileCreatedInDir = _File.fileCreatedInDir;\r\n	},\r\n\r\n	// Will forcefully write file. Createfolder if not exists\r\n	forceWriteFile : function(fullpath, content)\r\n	{\r\n		fullpath = modtask.modminipath.pathMap(fullpath);\r\n 		var folder = modtask.getPathNameFromFullPath(fullpath);\r\n		if (!modtask.folderExists(folder))\r\n			modtask.createFolder3(folder);\r\n		return modtask.writeFile(fullpath, content); 		\r\n	},\r\n\r\n	getTempDir : function()\r\n	{\r\n		return modtask.getPathNameFromFullPath(modtask.getTempFullFilePath(\"prefix\"));\r\n	},	\r\n\r\n	copy : function(fullsourcepath, destdir, destfilename)\r\n	{\r\n		fullsourcepath = modtask.modminipath.pathMap(fullsourcepath);\r\n		destdir = modtask.modminipath.pathMap(destdir);\r\n\r\n		var srcpath = modtask.getPathNameFromFullPath(fullsourcepath);\r\n		var srcname = modtask.getFilenameFromFullPath(fullsourcepath);\r\n		var map = {};\r\n		if (!destfilename)\r\n			destfilename = srcname;\r\n		map[srcname] = destfilename;\r\n		return modtask.mappedCopy(map, srcpath, destdir);\r\n	},\r\n \r\n\r\n	generateFileFromTemplate : function(_modtask, templatefile, outputfile, tokens)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n\r\n		templatefile = modtask.modminipath.pathMap(templatefile);\r\n		outputfile = modtask.modminipath.pathMap(outputfile);\r\n\r\n\r\n		modtask.Log(\"generating \" + outputfile);\r\n		var content = modtask.readFileEx(modtask, templatefile, true);			\r\n		modtask.writeToTextFile(outputfile, modstr.replaceTokens(content, tokens));		\r\n	},	\r\n\r\n	getFilenameFromFullPath : function(fullpath)\r\n	{\r\n		fullpath = modtask.modminipath.pathMap(fullpath);\r\n		var tmp = fullpath.split(modtask.seperator);\r\n		return tmp[tmp.length-1];\r\n	},	\r\n\r\n	// we cannot reference this back to kerne\\\\path -- because of the chain loader \r\n	getPathNameFromFullPath : function(fp)\r\n	{\r\n		fp = modtask.modminipath.pathMap(fp);\r\n		var ret = \"\", i=0;\r\n		var tmp = fp.split(modtask.seperator);\r\n		for(i=0; i < tmp.length - 1; ++i)\r\n			ret += tmp[i] + modtask.seperator;\r\n		return ret;  \r\n	},\r\n\r\n	pathCombine : function(path1, path2)\r\n	{\r\n		path1 = modtask.modminipath.pathMap(path1);\r\n		path2 = modtask.modminipath.pathMap(path2);\r\n\r\n\r\n		if (typeof(path1) != \"string\" || typeof(path2) != \"string\")\r\n			modtask.Fail(\"pathCombine: path1 or path2 nonstrings\");\r\n\r\n		if (path1.length == 0)\r\n			return path2;\r\n		if (path2.length == 0)\r\n			return path1;\r\n\r\n		var ret = path1 + modtask.seperator + path2 + modtask.seperator;\r\n		ret = modtask.strCleanDoubleBackSlash(ret, modtask.seperator);\r\n		if (ret.substr(ret.length-1, 1).indexOf(modtask.seperator) == 0)\r\n			ret = ret.substr(0, ret.length-1);\r\n		return ret;\r\n	},\r\n\r\n	emptyFolder : function(path)\r\n	{\r\n		modtask.removeFolder2(path);\r\n		modtask.createFolder3(path); \r\n	},		\r\n\r\n	// jscript regex bug: 	ret.replace(/\\\\\\\\/g, \"\\\\\") does not work!!!\r\n	strCleanDoubleBackSlash : function(str, rpl)\r\n	{\r\n		var dbl = modtask.seperator + modtask.seperator;\r\n		while(str.indexOf(dbl) >= 0)\r\n			str = str.replace(dbl, rpl);\r\n		return str;\r\n	},\r\n\r\n\r\n	 \r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"kernel\\\\logging\"],\r\n			[\"modtask\", \"minipath\"] \r\n		];\r\n		return ret;\r\n	}\r\n}\r\n"; 
INLINESTORE["kernel\\logging"] = "\r\nvar modtask = \r\n{\r\n	makeVerboseSensitive : function(mod)\r\n	{\r\n		if (typeof(mod[\"verbose\"]) == \"boolean\")\r\n		{\r\n			mod[\"tmplog\"] =mod[\"Log\"];\r\n			mod[\"Log\"] = function(x, doit, dontloop) { if (doit || mod[\"verbose\"] == true) return mod[\"tmplog\"](x, doit); } \r\n		}\r\n	}\r\n}\r\n"; 
INLINESTORE["path"] = "\r\nvar modtask = \r\n{\r\n	getRelativePath : function(fullPath, rootPath)\r\n	{\r\n		if (typeof(fullPath) != \"string\")\r\n			modtask.Fail(\"getRelativePath  fullPath\");\r\n\r\n		if (typeof(rootPath) != \"string\")\r\n			modtask.Fail(\"getRelativePath  rootPath\");\r\n	\r\n		if (rootPath.length == 0)\r\n			return fullPath;\r\n\r\n		// On windows, drive is optional, so make sure that the drive is present on both strings \r\n		if (fullPath.indexOf(\":\") < 0)\r\n			fullPath = \"x:\" + fullPath;\r\n		if (rootPath.indexOf(\":\") < 0)\r\n			rootPath = \"x:\" + rootPath;\r\n\r\n		fullPath = fullPath.substr(2, fullPath.length-2);\r\n		rootPath = rootPath.substr(2, rootPath.length-2);\r\n\r\n		if (!modtask.modstr.startsWith(fullPath, rootPath))\r\n		{\r\n			// It could be because of ..\r\n			fullPath = this.eliminateDoubleDot(fullPath);	\r\n			rootPath = this.eliminateDoubleDot(rootPath);	\r\n		}\r\n\r\n		var prefix = \"\";var origroot = rootPath;\r\n		while(!modtask.modstr.startsWith(fullPath, rootPath) && rootPath.length > 0)\r\n		{\r\n			prefix = \"\\\\..\" + prefix;\r\n			// Shift-up\r\n			rootPath = modtask.moveUp(rootPath);\r\n		} \r\n\r\n		if (rootPath.length < 1)\r\n		{\r\n			modtask.Fail(\"getRelativePath impossible conversion for '\" + fullPath + \"' / '\" + origroot + \"'\");\r\n		} \r\n\r\n		if (!modtask.modstr.endsWith(rootPath, \"\\\\\"))\r\n			rootPath = rootPath + \"\\\\\";\r\n		var ret = fullPath.substr(rootPath.length, fullPath.length-rootPath.length);\r\n		return prefix + \"\\\\\" + this.eliminateDoubleDot(ret);			\r\n	},\r\n\r\n	moveUp : function(path)\r\n	{\r\n		if (modtask.modstr.endsWith(path, \"\\\\\"))\r\n			path = path.substr(0, path.length-1);\r\n 		var pth = path.split(\"\\\\\");\r\n		var i;\r\n		var ret = \"\";\r\n		for(i=0; i < pth.length-1; ++i)\r\n		{\r\n			ret = ret + pth[i] + \"\\\\\";\r\n		} \r\n		if (ret.length > 1)\r\n			ret = ret.substr(ret, ret.length-1);\r\n\r\n		return ret; \r\n	},		\r\n\r\n	eliminateDoubleDot : function(path)\r\n	{\r\n		var pth = path.split(\"\\\\\");\r\n		var i;\r\n		var ret = \"\";\r\n		for(i=0; i < pth.length; ++i)\r\n		{\r\n			if (i+1 < pth.length && pth[i+1] == \"..\")\r\n			{\r\n				i+=1;\r\n				continue;\r\n			}\r\n			ret = ret + pth[i] + \"\\\\\";\r\n		} \r\n		ret = ret.substr(ret, ret.length-1);\r\n		return ret;\r\n	},\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n   		var ret =  [\r\n			[\"modtask\", \"core\\\\string\"] \r\n		];\r\n 		return ret;		\r\n	},\r\n\r\n	init : function()\r\n	{\r\n		modtask.modstr = modtask.ldmod(\"core\\\\string\");\r\n	}\r\n}\r\n"; 
INLINESTORE["host\\nodejs\\file"] = "\r\nvar modtask = \r\n{\r\n	fso : false,\r\n	filemod : false,\r\n	commonmod : false,\r\n	ForReading : 1,	\r\n\r\n	seperator : \"/\",\r\n	newLine : \"\\r\\n\",\r\n\r\n	init : function()\r\n	{\r\n		modtask.modminipath = modtask.ldmod(\"minipath\");\r\n		modtask.seperator = modtask.modminipath.seperator;\r\n\r\n		modtask.fso = require('fs');\r\n		modtask.commonmod = modtask.ldmod(\"host\\\\nodejs\\\\filecommon\");\r\n	},\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.commonmod.afterInit(_filemod);\r\n		modtask.filemod = _filemod;\r\n		modtask.fileCreatedInDir = modtask.commonmod.fileCreatedInDir;\r\n	},\r\n\r\n 	createFolder2 : function(_modtask, path)\r\n	{\r\n		var i;\r\n		var pth = path.split(modtask.seperator);\r\n		var pthtocreate = \"\";\r\n		for(i=0; i < pth.length; ++i)\r\n		{\r\n			pthtocreate += pth[i] + modtask.seperator ;\r\n			if (!modtask.folderExists(pthtocreate))\r\n			{\r\n				modtask.fso.mkdirSync(pthtocreate);\r\n			}\r\n			else\r\n			{	\r\n			}\r\n		}			\r\n	}, \r\n\r\n	iterateFilecontent : function(_modtask, context)  \r\n	{\r\n		if (!modtask.FileExists(context[\"path\"]))\r\n			modtask.Fail(\"iterateFilecontent: file not exist \" + context[\"path\"]);\r\n\r\n		var f = modtask.readFileEx(_modtask, context[\"path\"], true);\r\n		var lnno = 0;\r\n		var newln;\r\n		f = f.split(\"\\n\");\r\n		while (lnno < f.length)\r\n		{\r\n			newln = f[lnno];\r\n			lnno++;\r\n			if (context[\"fn\"](lnno, \"\", newln) == \"break\")\r\n				break;\r\n		}\r\n	},	\r\n\r\n	removeFolder : function(_modtask, destdir)\r\n	{\r\n		var fs = modtask.fso;\r\n		var deleteFolderRecursive = function(path) {\r\n		  if( fs.existsSync(path) ) {\r\n		    fs.readdirSync(path).forEach(function(file,index){\r\n		      var curPath = path + modtask.seperator + file;\r\n		      if(fs.lstatSync(curPath).isDirectory()) { // recurse\r\n			deleteFolderRecursive(curPath);\r\n		      } else { // delete file\r\n				fs.unlinkSync(curPath);\r\n		      }\r\n		    });\r\n		    fs.rmdirSync(path);\r\n		  }\r\n		}; \r\n		deleteFolderRecursive(destdir);\r\n	},	\r\n\r\n	getTempFullFilePath : function(prefix)\r\n	{\r\n		if (!prefix)\r\n			prefix = \"\";\r\n		return modtask.getTempFullPath() +  prefix + modtask.getTempFilename();\r\n	},\r\n\r\n	getTempFullPath : function()\r\n	{\r\n		var ret = require('os').tmpdir();\r\n		if (!ret.match(/\\/$/)) ret += modtask.seperator;\r\n		return ret;\r\n	},		\r\n\r\n	getTempFilename : function()\r\n	{\r\n		return 'nodejs_temp_' + new Date().getTime() + Math.round(Math.random() * 1000000);\r\n	},\r\n\r\n	writeFile : function(file, str)\r\n	{\r\n		return modtask.fso.writeFileSync(file, str);\r\n	},		\r\n\r\n	readFileEx : function(_modtask, name, absolute)\r\n	{\r\n		var path = name;\r\n\r\n		if (!absolute)\r\n			modtask.Fail(\"readFileEx.nonabsolutenotsupported\"); \r\n		if (!modtask.FileExists(path))\r\n			modtask.Fail(\"readFileEX on non existent file: \" + path);\r\n\r\n		try \r\n		{\r\n			var ret = modtask.fso.readFileSync(path).toString(); \r\n			return ret; \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"readFileEx '\" + path + \"': \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	appendToFile : function(path, str)\r\n	{\r\n		modtask.fso.appendFileSync(path, str + modtask.newLine);	\r\n	},\r\n\r\n	folderExists : function(path)\r\n	{\r\n		return modtask.FileExists(path, true);\r\n	},\r\n	\r\n\r\n	FileExists : function(path, checkFordir)		\r\n	{ 	\r\n		var outcome = false;\r\n		try {\r\n		    stats = modtask.fso.lstatSync(path);\r\n		    if (checkFordir)\r\n			outcome = stats.isDirectory();\r\n		    else \r\n			outcome = stats.isFile();\r\n		}\r\n		catch (e) { \r\n		}\r\n		return outcome;\r\n	},\r\n	\r\n\r\n	deleteFile: function(path)\r\n	{\r\n		if (!modtask.FileExists(path))\r\n			return ;\r\n		modtask.fso.unlinkSync(path);\r\n	},\r\n\r\n\r\n	mappedCopy : function(map, rootdir, destdir)\r\n	{\r\n		modtask.Fail('Mapped copy moved to deploy/copy');	\r\n	},\r\n\r\n	MoveFile : function(_modtask, src, dst)\r\n	{\r\n	       	if (!modtask.FileExists(src))\r\n			modtask.Fail(\"source.file.not.exists '\" + src + \"'\");		\r\n		var name = modtask.filemod.getFilenameFromFullPath(src);\r\n\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		var dest;\r\n		if (modstr.startsWith(dst, \"file:\"))\r\n			dest = dst.substr(5, dst.length-5);\r\n		else \r\n			dest = modtask.filemod.pathCombine(dst, name);\r\n\r\n		try\r\n		{	\r\n			modtask.fso.renameSync(src, dest);  \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"modtask.fso.renameSync \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	iterateFoldercontent : function(_modtask, context)\r\n	{\r\n		if (!context[\"path\"])\r\n			_modtask.Fail(\"iterateFoldercontent.path not set\");\r\n\r\n      if (!context[\"method\"])\r\n         context[\"method\"] = \"shallow\";         \r\n\r\n		var dir = context[\"path\"];\r\n\r\n		if (!modtask.folderExists(dir))\r\n			_modtask.Fail(\"iterateFoldercontent on non existent dir: \" + dir);\r\n\r\n	// 	var srcFolder = modtask.fso.readdirSync( dir );    	\r\n		var files = modtask.fso.readdirSync( dir );    \r\n	        files.map(function(_item)\r\n				{\r\n\r\n 	\r\n					_item += \"\";\r\n			var fname = modtask.filemod.getFilenameFromFullPath(_item); \r\n			context[\"fn\"](\"\", \"\", fname, dir, _item);\r\n				}); \r\n\r\n      if (context[\"method\"] == \"deep\")\r\n      {\r\n	      modtask.Fail('DEEEP_HAS_NOT_BEEN_IMPLEMENTED');\r\n          var subFlds = new Enumerator(srcFolder.SubFolders);\r\n          var s = \"\";\r\n          for (; !subFlds.atEnd(); subFlds.moveNext()) \r\n          {\r\n             context[\"path\"] = subFlds.item() + \"\";\r\n             modtask.iterateFoldercontent(_modtask, context);\r\n          }\r\n      }      \r\n	},	\r\n\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"os\\\\windows\\\\filecommon\"]\r\n		];\r\n		return ret;\r\n	}	\r\n	\r\n}\r\n"; 
INLINESTORE["proc"] = "\r\nvar modtask = \r\n{\r\n	runApp : false,\r\n	str : false,\r\n	file : false,\r\n\r\n	runAppAndFailIfneeded : function(s, channel, outputstr, _modtask, shouldnotexist, logoutput, async, returnexitcode)\r\n	{\r\n		var rt = modtask.runApp(s, false, async);\r\n		var res;\r\n\r\n		if (returnexitcode && !async)\r\n			return rt[\"ExitCode\"];\r\n		\r\n		if (channel == \"all\")\r\n			res = rt[\"StdErr\"] + \" \" + rt[\"StdOut\"];\r\n		else \r\n			res= rt[channel];\r\n\r\n		if (rt.StdErr && rt.StdErr.toUpperCase().indexOf(\"IS NOT RECOGNIZED AS AN INTERNAL OR EXTERNAL COMMAND\") >= 0 )\r\n			_modtask.Fail(rt.StdErr);\r\n		\r\n		if (logoutput)\r\n			_modtask.Log(res);\r\n\r\n		if (!outputstr)\r\n			return res;\r\n		if (shouldnotexist)\r\n		{\r\n			if (res.indexOf(outputstr) >=0)\r\n				_modtask.Fail(\"Error running app\\n\" + s + \": '\" + res + \"'\");\r\n			else \r\n				return res;\r\n		}\r\n		else \r\n		{\r\n			if (res.indexOf(outputstr) < 0)\r\n				_modtask.Fail(\"Error running app\\n\" + s + \": '\" + res + \"'\");\r\n			else \r\n				return res;\r\n		}\r\n	},\r\n\r\n	runGUIApp : function(s, visible, async)\r\n    	{\r\n		modtask.rawRun(s, visible, async); 		\r\n	},	\r\n\r\n	init : function()\r\n	{\r\n		modtask.file = modtask.ldmod(\"file\");\r\n		modtask.str = modtask.ldmod(\"core\\\\string\");\r\n		var _Proc = modtask.ldmod(Kernel.getModulePath(\"proc\"));\r\n		if (_Proc[\"afterInit\"])\r\n			_Proc[\"afterInit\"](modtask); \r\n  		modtask.getBinPath = _Proc.getBinPath;\r\n		modtask.createProcess = function(s, visible, async) { return modtask.runGUIApp(s, visible, async);} \r\n	        modtask.rawRun = _Proc.rawRun;\r\n	        modtask.runApp = _Proc.runApp;		\r\n		modtask.getEnvironmentVariable = _Proc.getEnvironmentVariable;\r\n		modtask.constructShellCmdline = _Proc.constructShellCmdline;\r\n	},\r\n \r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n 	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"file\"]	\r\n		];\r\n		return ret;\r\n	}	\r\n}\r\n"; 
INLINESTORE["os\\windows\\filecommon"] = "\r\nvar modtask = \r\n{\r\n	filemod : false,\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.filemod = _filemod;\r\n	},	\r\n\r\n	fileCreatedInDir : function(dir, ext, blocking, timeout)\r\n	{\r\n		var proc = modtask.ldmod(\"proc\");\r\n		var filecreated = false;\r\n		var tmp = \"\";\r\n		var cmd = \"cmd /c dir /b \" + dir + \"\\\\*.\" + ext;\r\n		var time = 0 ;\r\n		var delta = 1000;\r\n\r\n		do \r\n		{\r\n			tmp = proc.runApp(cmd)[\"StdOut\"].replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/ */, \"\");\r\n			filecreated = tmp.length > 0;\r\n			if (filecreated)\r\n				break;	\r\n			if (!blocking || (time > timeout))\r\n				return false;\r\n 			modtask.Log(\"Waiting for .\" + ext + \" in \" + dir + \" t = \" + time + \"/\" + timeout);\r\n			time += delta;\r\n			modtask.Sleep(delta);			\r\n		} while(!filecreated);\r\n		filecreated = modtask.filemod.pathCombine(dir, tmp);\r\n		return filecreated;\r\n	},\r\n\r\n	search : function(_modtask, context)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		if (!context[\"expr\"])\r\n			_modtask.Fail(\"cotext.expr is null\");\r\n		var proc = modtask.ldmod(\"proc\");		\r\n		var ret = proc.runApp(\"dir /s/b/A-D \\\"\" + context.expr + \"\\\"\")[\"StdOut\"].split(\"\\n\");\r\n		var i;\r\n		for(i=0; i < ret.length; ++i)\r\n		{\r\n			ret[i]=ret[i].replace(/^\\s+/g, \"\");\r\n			ret[i] = modstr.strClean1013(ret[i],\"\");			\r\n			if (ret[i].length > 0)\r\n				context.fn(i, \"\", ret[i]);\r\n		}\r\n	},	\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"]	\r\n		];\r\n		return ret;\r\n	} \r\n}\r\n"; 
INLINESTORE["host\\nodejs\\filecommon"] = "\r\nvar modtask = \r\n{\r\n	filemod : false,\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.filemod = _filemod;\r\n	},	\r\n\r\n	fileCreatedInDir : function(dir, ext, blocking, timeout)\r\n	{\r\n		var proc = modtask.ldmod(\"proc\");\r\n		var filecreated = false;\r\n		var tmp = \"\";\r\n		var cmd = \"cmd /c dir /b \" + dir + \"\\\\*.\" + ext;\r\n		var time = 0 ;\r\n		var delta = 1000;\r\n\r\n		do \r\n		{\r\n			tmp = proc.runApp(cmd)[\"StdOut\"].replace(/\\n/g, \"\").replace(/\\r/g, \"\").replace(/ */, \"\");\r\n			filecreated = tmp.length > 0;\r\n			if (filecreated)\r\n				break;	\r\n			if (!blocking || (time > timeout))\r\n				return false;\r\n 			modtask.Log(\"Waiting for .\" + ext + \" in \" + dir + \" t = \" + time + \"/\" + timeout);\r\n			time += delta;\r\n			modtask.Sleep(delta);			\r\n		} while(!filecreated);\r\n		filecreated = modtask.filemod.pathCombine(dir, tmp);\r\n		return filecreated;\r\n	},\r\n\r\n	search : function(_modtask, context)\r\n	{\r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		if (!context[\"expr\"])\r\n			_modtask.Fail(\"cotext.expr is null\");\r\n		var proc = modtask.ldmod(\"proc\");		\r\n		var ret = proc.runApp(\"dir /s/b/A-D \\\"\" + context.expr + \"\\\"\")[\"StdOut\"].split(\"\\n\");\r\n		var i;\r\n		for(i=0; i < ret.length; ++i)\r\n		{\r\n			ret[i]=ret[i].replace(/^\\s+/g, \"\");\r\n			ret[i] = modstr.strClean1013(ret[i],\"\");			\r\n			if (ret[i].length > 0)\r\n				context.fn(i, \"\", ret[i]);\r\n		}\r\n	},	\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"]	\r\n		];\r\n		return ret;\r\n	} \r\n}\r\n"; 
INLINESTORE["os\\windows\\file"] = "\r\nvar modtask = \r\n{\r\n	fso : false,\r\n	filemod : false,\r\n	commonmod : false,\r\n	ForReading : 1,		\r\n\r\n	init : function()\r\n	{\r\n		modtask.fso = new ActiveXObject(\"Scripting.FileSystemObject\");\r\n		modtask.commonmod = modtask.ldmod(\"os\\\\windows\\\\filecommon\");\r\n	},\r\n\r\n	afterInit : function(_filemod)\r\n	{\r\n		modtask.commonmod.afterInit(_filemod);\r\n		modtask.filemod = _filemod;\r\n		modtask.fileCreatedInDir = modtask.commonmod.fileCreatedInDir;\r\n		modtask.search = modtask.commonmod.search;\r\n	},\r\n\r\n 	createFolder2 : function(_modtask, path)\r\n	{\r\n		var i;\r\n		var pth = path.split(\"\\\\\");\r\n		var pthtocreate = \"\";\r\n		for(i=0; i < pth.length; ++i)\r\n		{\r\n			pthtocreate += pth[i] + \"\\\\\";\r\n			if (!modtask.fso.FolderExists(pthtocreate))\r\n			{\r\n				if(!modtask.fso.CreateFolder(pthtocreate))\r\n					modtask.Fail(\"Cannot create folder: \" + pthtocreate);\r\n			}\r\n			else\r\n			{	\r\n			}\r\n		}			\r\n	}, \r\n\r\n	iterateFilecontent : function(_modtask, context)  \r\n	{\r\n		if (!context[\"path\"])\r\n			modtask.Fail(\"path not set\");\r\n\r\n		if (!modtask.FileExists(context[\"path\"]))\r\n			modtask.Fail(\"iterateFilecontent: file not exist \" + context[\"path\"]);\r\n\r\n		var f = modtask.fso.OpenTextFile(context[\"path\"], modtask.ForReading, true);\r\n		var lnno = 0;\r\n		var newln;\r\n		while (!f.AtEndOfStream)\r\n		{\r\n			newln = f.ReadLine();\r\n			lnno++;\r\n			if (context[\"fn\"](lnno, \"\", newln) == \"break\")\r\n				break;\r\n		}\r\n		f.Close();\r\n	},	\r\n\r\n	removeFolder : function(_modtask, destdir)\r\n	{\r\n 		var cmd = \"rmdir /s/q \\\"\" + destdir + \"\\\"\";\r\n		var proc = modtask.ldmod(\"proc\");		\r\n 		var result = proc.runApp(cmd)[\"StdOut\"]; \r\n\r\n		// Will be silent on success, otherwise it will say error \r\n		result = result.replace(/\\r/g, \"\").replace(/\\n/g, \"\");		\r\n		if (result.length > 0)\r\n			modtask.Fail(\"removeFolder failed on \" + destdir + \" with error \" + result);		\r\n	},	\r\n\r\n	getTempFullFilePath : function(prefix)\r\n	{\r\n		if (!prefix)\r\n			prefix = \"\";\r\n		return modtask.getTempFullPath() +  prefix + modtask.getTempFilename();\r\n	},\r\n\r\n	getTempFullPath : function()\r\n	{\r\n		var TemporaryFolder = 2;\r\n		return modtask.fso.GetSpecialFolder(TemporaryFolder) + \"\\\\\";\r\n	},		\r\n\r\n	getTempFilename : function()\r\n	{\r\n		return modtask.fso.GetTempName();\r\n	},\r\n\r\n	writeFile : function(file, str)\r\n	{\r\n		var ForWriting = 2;\r\n 		var txtFile; \r\n\r\n		// If str is unicode this will fail \r\n		try\r\n		{\r\n			txtFile = modtask.fso.OpenTextFile(file, ForWriting, true);\r\n			txtFile.Write(str);\r\n		}\r\n		catch(e) \r\n		{\r\n			txtFile = modtask.fso.CreateTextFile(file, true, true);\r\n			txtFile.Write(str);\r\n		} 		\r\n		txtFile.Close();	\r\n	},		\r\n\r\n\r\n\r\n	readFileEx : function(_modtask, name, absolute)\r\n	{\r\n		var path = name;\r\n		if (!absolute)\r\n			modtask.Fail(\"readFileEx.nonabsolutenotsupported\"); \r\n		if (!modtask.fso.FileExists(path))\r\n			modtask.Fail(\"readFileEX on non existent file: \" + path);\r\n\r\n		try \r\n		{\r\n			var txtFile = modtask.fso.OpenTextFile(path , modtask.ForReading, \r\n					false,  // do not create\r\n					0 // open as ascii\r\n					);	\r\n			var ret =  txtFile.AtEndOfStream ? \"\" : txtFile.ReadAll();\r\n			txtFile.Close(); \r\n			return ret; \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"readFileEx '\" + path + \"': \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	appendToFile : function(path, str)\r\n	{\r\n		var ForAppending = 8;\r\n		var txtFile = modtask.fso.OpenTextFile(path, ForAppending, true);\r\n		var ret = txtFile.WriteLine(str);\r\n		txtFile.Close(); 	\r\n	},\r\n\r\n	FileExists : function(path)		\r\n	{\r\n		return modtask.fso.FileExists(path);\r\n	},\r\n	\r\n\r\n	deleteFile: function(path)\r\n	{\r\n		if (path.match(/ /))\r\n			path = \"\\\"\" + path + \"\\\"\";\r\n		if (!modtask.fso.FileExists(path))\r\n			return ;\r\n		modtask.fso.DeleteFile(path);\r\n	},\r\n\r\n	folderExists : function(path)\r\n	{\r\n		return modtask.fso.FolderExists(path);\r\n	},\r\n\r\n	MoveFile : function(_modtask, src, dst)\r\n	{\r\n	       	if (!modtask.FileExists(src))\r\n			modtask.Fail(\"source.file.not.exists '\" + src + \"'\");		\r\n		var name = modtask.filemod.getFilenameFromFullPath(src);\r\n\r\n		// placeholder \r\n		var modstr = modtask.ldmod(\"core\\\\string\");\r\n		var dest;\r\n		if (modstr.startsWith(dst, \"file:\"))\r\n			dest = dst.substr(5, dst.length-5);\r\n		else \r\n			dest = modtask.filemod.pathCombine(dst, name);\r\n\r\n		try\r\n		{\r\n			modtask.fso.MoveFile(src, dest);  \r\n		}\r\n		catch(e)\r\n		{\r\n			modtask.Fail(\"windows.fso.MoveFile \" + modtask.exceptionToString(e));\r\n		}\r\n	},\r\n\r\n	iterateFoldercontent : function(_modtask, context)\r\n	{\r\n\r\n		if (!context[\"path\"])\r\n			_modtask.Fail(\"iterateFoldercontent.path not set\");\r\n\r\n      if (!context[\"method\"])\r\n         context[\"method\"] = \"shallow\";         \r\n\r\n		var dir = context[\"path\"];\r\n		if (!modtask.folderExists(dir))\r\n			_modtask.Fail(\"iterateFoldercontent on non existent dir: \" + dir); \r\n\r\n		var srcFolder = modtask.fso.GetFolder( dir );    	\r\n		var files = new Enumerator( srcFolder.files );    \r\n		for(; !files.atEnd(); files.moveNext() )   \r\n		{			\r\n			var fname = modtask.filemod.getFilenameFromFullPath(files.item()+\"\"); \r\n			context[\"fn\"](\"\", \"\", fname, dir, files.item()+\"\");			\r\n		}	\r\n\r\n      if (context[\"method\"] == \"deep\")\r\n      {\r\n          var subFlds = new Enumerator(srcFolder.SubFolders);\r\n          var s = \"\";\r\n          for (; !subFlds.atEnd(); subFlds.moveNext()) \r\n          {\r\n             context[\"path\"] = subFlds.item() + \"\";\r\n             modtask.iterateFoldercontent(_modtask, context);\r\n          }\r\n      }      \r\n	},	\r\n\r\n\r\n	getDependencies : function(moduleconfig)\r\n	{\r\n 		var ret = \r\n		[\r\n			[\"modtask\", \"proc\"],\r\n	       		[\"modtask\", \"core\\\\string\"],\r\n			[\"modtask\", \"os\\\\windows\\\\filecommon\"]\r\n		];\r\n		return ret;\r\n	}	\r\n	\r\n}\r\n"; 
INLINESTORE["host\\cscript\\base"] = "\r\nvar modtask =\r\n{\r\n	platobject : false,\r\n\r\n	modspath : \r\n	{\r\n		\"file\" : \"os\\\\windows\\\\file\",\r\n		\"proc\" : \"os\\\\windows\\\\proc\",\r\n		\"osdependentfilecommon\" : \"os\\\\windows\\\\filecommon\",\r\n		\"http\" : \"host\\\\cscript\\\\http\",\r\n	        \"pinger\" : \"host/cscript/pinger\"\r\n	},\r\n\r\n	getModulePath : function(name)\r\n	{\r\n		if (typeof(modtask.modspath[name]) != \"string\")\r\n			Kernel.Fail(\"getModulePath \" + name);\r\n		return modtask.modspath[name];\r\n	},\r\n\r\n	endRuntime : function()\r\n	{\r\n		Kernel.Fail(\"endRuntime for cscript\");\r\n	},		\r\n\r\n 	showUnhandledKernelExceptionMsg : function(str)\r\n	{\r\n		try { WScript.StdOut.WriteLine(str);} catch(e) { WScript.StdOut.WriteLine(\"host.cscript.showUnhandledKernelExceptionMsg.Failed\"); }\r\n	},		\r\n	\r\n	\"Log\" : function(s) \r\n	{\r\n 		try { WScript.StdOut.WriteLine(s); } catch(e) { WScript.StdOut.WriteLine(\"host.cscript.Log.Failed\"); }\r\n	},\r\n\r\n	\"Sleep\" : function(miliseconds) \r\n	{\r\n		WScript.Sleep(miliseconds);	\r\n	},\r\n\r\n	\"exceptionToString\" : function(e) \r\n	{ \r\n		var ret = \"\";\r\n		if (typeof(e.message) == \"string\" && e.message.length > 0)\r\n			ret = e.message;\r\n		else \r\n		{\r\n			for(p in e)\r\n			{\r\n				ret += p + \" \" + e[p] + \" \";\r\n				if (p == \"number\") \r\n				{\r\n					var map =\r\n					{\r\n						\"-2147417848\" : \"is 0x80010108 which indicates \",\r\n						// http://www.allstarid.com/Files/Docs/ASP%20-%20Oracle%20kb%20306518.pdf\r\n						\"-2147467259\" : \"is 0x80004005 which indicates data access error or permission denied.\"\r\n					}\r\n					if (map[e[p]+\"\"])\r\n					{\r\n						ret+= map[e[p]+\"\"] + \" \";\r\n					} \r\n				}\r\n 			}\r\n		}\r\n		return ret;\r\n	}		\r\n}\r\n"; 


var Minicore = 
{
	ERR_DOESNOT_EXIST 	: "Does not exist",
 	newLine : "\r\n",
	rootModule : false,
	isInlineFlat : false,
	loadObjectOverwrite : false,

	doOutcomeException : function(msg)
	{
		var hash = {};
		hash["message"] = msg;
		throw hash;
	},

 	EncodeFailStr : function(msg)
	{
		return "FAIL, " + msg;
	},

	toStringIfNeeded : function(res)
	{
		var rt = "";
		var p;
		if (typeof(res) == "object") 
		{
			for(p in res)
			{
				rt += "\r\n" + p + ": " + res[p];
			}
		}
		else 
		{
			try { rt = res + ""; } catch(e) { rt = "toStringIfNeeded.failed on " + typeof(res); };
		}
		return rt;
	},	

	Log : function(msg)
	{
  	},		
	
	Fail : function(msg)
	{
		msg = Minicore.toStringIfNeeded(msg);			
		msg = Minicore.EncodeFailStr(msg);
		Minicore.doOutcomeException(msg);
	},

	Sleep : function(miliseconds)
	{
 	},	

	loadModuleInModtask : function(modtask, modulename, donotvalidate, funcs, dontcallinit)
	{
    		var mod = Minicore.loadModule(modulename, modtask, true, funcs); 
 		Minicore.inheritFromModtask(modtask, mod);
		return Minicore.postLoadModule(modtask, mod, dontcallinit);
	},

	postLoadModule : function(modtask, mod, dontcallinit) 
	{
 		mod["ldmod"] = function(x) { if (x.indexOf("rel:") == 0) return mod.ldmod(mod.ldmod("kernel\\path").resolve(mod.__myname, x)); else return Kernel.loadModuleInModtask(mod, x); };
      mod["__modtask"] = modtask;			
		mod["sp"] = function(p,v) { 
			var p1;if (typeof(p) == "object") { for(p1 in p) mod["sp"](p1, p[p1]); return mod; }  
			mod[p] = v; return mod; 
		};
		mod["setProp"] = mod["sp"];
		if (mod["Log"]) {
			mod["Log"] = function(x) { Kernel.Log(x); };	
	//		if (!mod["__logname"]) mod["__logname"] = "";
		//	mod["Log"] = function(x) { return modtask.Log(mod["__logname"] + " " + x); } 							
		}
		if (typeof(mod["init"]) == "function")
		{
			if (dontcallinit) { } else { mod["init"]();} 
		}
 		return mod;
	},		

	inheritFromModtask : function(modtask, mod)
	{	 
		var names = ["Log", "Fail", "Sleep", "exceptionToString", "doOutcomeException"];
		var i=0;
		for(i=0; i < names.length; ++i) 
			mod[names[i]] = modtask[names[i]];
	},

	loadModule : function(_modtask, modulename, compatparam, funcs) 
	{
		// support modulename, donotvalidate, modtask 
		if (typeof(_modtask) == "string")
		{
			// Old format 
			var t = modulename;
			modulename = _modtask;
			_modtask = t;
		}

		if (!_modtask)
		{
			_modtask = Minicore;
		}

		if (Minicore.loadObjectOverwrite == false) 
		{
			return Minicore.loadObject2(_modtask, "modtask", modulename, false, true, funcs);
		}
		else 
		{
			return Minicore.loadObjectOverwrite(_modtask, "modtask", modulename, false, true, funcs);
		}
	},

	loadObject2 : function(_modtask, objecttype, objectname, inithash, donotcallinit, funcs)
	{
		Minicore.flattenTheInlines();
		if (typeof(funcs) != "object")
			funcs = {};
		if (typeof(funcs["existfunc"]) != "function")
			funcs["existfunc"] = Minicore.objectExist;

		if (typeof(funcs["parsefunc"]) != "function")
			funcs["parsefunc"] = Minicore.miniParseObj;		


 		if (!funcs["existfunc"](objecttype, objectname))
		{
 			_modtask.Fail(Minicore.EncodeDecode_encodeErrorMessage("loadObject2", Minicore.ERR_DOESNOT_EXIST, objectname));  
			return ;
		}
		return Minicore.rawLoadObject(_modtask, objecttype, objectname, funcs["parsefunc"]); 
	},

	rawLoadObject : function(_modtask, objecttype, objectname, parsefunc)
	{
		var retObj = {};
		var __loadObject2Path = "";			
		__loadObject2Path = objectname;
  		retObj = parsefunc(_modtask, objectname, objecttype);
	        if (typeof(retObj["__loadObject2Path"]) != "string")
			retObj["__loadObject2Path"] = __loadObject2Path;
	        if (typeof(retObj["__myname"]) != "string")
			retObj["__myname"] = objectname; 
		return retObj;
	},

	flattenTheInlines : function()
	{
		if (Minicore.isInlineFlat)
			return ;

		Minicore.isInlineFlat = true;
		if (typeof(INLINESTORE) == "object")
		{
			var p ;
			for(p in INLINESTORE)
			{
				var name = p.split("\\");
				name = name[name.length-1];
				if (!INLINESTORE[name]) 
				{
					// Do not override something else !
					INLINESTORE[name] = INLINESTORE[p];
				}
			}
		}		
	},		

	objectExist : function(objecttype, objectname)
	{
		var __tempobjstore;
		try
		{	
			eval("__tempobjstore = " + Minicore.getObjectInlineVar(objectname));
		}
		catch(e)
		{
			return false;
		}
		return typeof(__tempobjstore) == "string";
	},	

	JscriptToAA : function(modtask, JS, objstoredname)
	{
		var objcontents;
		try
		{	
			eval(JS + "; objcontents = " + objstoredname + ";");	
		}
		catch(e)
		{
			modtask.Fail("JscriptToAA: eval failed on '" + objstoredname +"' :" +  e.description); 
		}
		return objcontents;
	},

	nakedParseStr : function(modtask, objname, objecttype, unparsedstrform)
	{
		var __tempobjstore = "";
		if (!objecttype)
			objecttype = "modtask";
		if (!unparsedstrform)
			unparsedstrform = Minicore.getInlineJScriptForObj(objname);
		__tempobjstore = unparsedstrform; 
		__tempobjstore = Minicore.JscriptToAA(modtask, __tempobjstore, objecttype); 		
		return __tempobjstore;
	},

	miniParseObj : function(modtask, objname, objecttype, unparsedstrform)
	{
		try
		{
			return Minicore.nakedParseStr(modtask, objname, objecttype, unparsedstrform);
		}
		catch(e)
		{
			modtask.Fail("miniParseObj failed to parse '" + objname + "' from inlines. ");  
		}

	},

	getInlineJScriptForObj : function(objname)
	{
		var __tempobjstore = ""; 
		eval("__tempobjstore = Minicore.decodeObjectStrForStorage(" + Minicore.getObjectInlineVar(objname) + ", objname);");
		return __tempobjstore;
	},

	decodeObjectStrForStorage : function(str)
	{
		return str;
	},

	getObjectInlineVar : function(objectname)
	{
		return "INLINESTORE[\"" + Minicore.EncodeDecode_encodeStringToJSStr(objectname) + "\"]";
	},

	EncodeDecode_encodeErrorMessage : function(action, errormsg, context)
	{
		return action + ", " + errormsg + ": " + context;
	},

	EncodeDecode_encodeStringToJSStr : function(str)
	{
		str = str.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
		var strs = {};

		strs[Minicore.newLine] = "\\" + "r" + "\\" + "n";
		strs["\r"] = "\\" + "r"; 
		strs["\n"] = "\\" + "n";

		var p;
		for(p in strs)
		{
			while (str.indexOf(p) >= 0)
				str = str.replace(p, strs[p]);
		}
		return str;
	}
};


var Kernel=Minicore;

function onSystemStart(platobject)
{
	var p=false;for(p in INLINESTORE) { break; };
	if (p)
	{
		Kernel.rootModule = Kernel.loadModuleInModtask(Kernel, p);
		return Kernel.rootModule.servicecallback("systemstart", platobject);
	}	
} 




function startnodejs() { if (typeof(process) == 'object') { 
onSystemStart({'overridehostingmodule' : 'host\\nodejs\\base', 'platobject' : process });if (typeof(process.argv) == 'object') { if (process.argv.length == 3) { Kernel.rootModule.externalCall({'fn': Kernel.rootModule.usermodule.onCommandLine, 'p' : process.argv[2] });}}; } 
 } if (typeof(process) == 'object')  startnodejs(); 
function startcscript() { if (typeof(WScript) == 'object') { 
onSystemStart({'overridehostingmodule' : 'host\\cscript\\base', 'platobject' : WScript});if (typeof(WScript.Arguments) == 'object') { if (WScript.Arguments.Count() == 1) { Kernel.rootModule.externalCall({'fn': Kernel.rootModule.usermodule.onCommandLine, 'p' : WScript.Arguments.Item(0)});}}; } 
 } if (typeof(WScript) == 'object')  startcscript(); 

